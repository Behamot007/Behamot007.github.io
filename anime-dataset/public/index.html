<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Anime Character Dataset</title>
  <style>
    :root { --gap: 1rem; --border:#e3e3e3; --bg:#f7f7f7; }
    *{ box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding: var(--gap); }
    h1 { margin: 0 0 .5rem 0; }
    .layout { display:grid; grid-template-columns: minmax(280px, 440px) 1fr; gap: var(--gap); }
    @media (max-width: 900px){ .layout { grid-template-columns: 1fr; } }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: var(--gap); background: #fff; }
    .muted { color:#666; font-size:.9rem; }
    .search-box { display:flex; flex-direction: column; gap:.5rem; }
    .filters { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:.5rem; }
    .legend { display:flex; gap:.5rem; align-items:center; margin-top:.25rem; font-size:.9rem; color:#555; }
    .dot { width:.9rem; height:.9rem; border-radius:50%; display:inline-block; border:1px solid #999; }
    .dot.green { background:#c8e6c9; }
    .dot.yellow{ background:#fff9c4; }
    .dot.red   { background:#ffcdd2; }

    input, select { width:100%; padding:.6rem; border:1px solid #ccc; border-radius: 8px; }
    select { height: 320px; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:.75rem; }
    @media (max-width: 700px){ .grid { grid-template-columns: 1fr; } }

    .imgbox { display:flex; align-items:flex-start; gap:.75rem; }
    .imgbox img { width:96px; height:96px; object-fit:cover; border-radius:10px; border:1px solid var(--border); background:#fafafa; }
    .taghint { font-size:.85rem; color:#777; }

    .toolbar { display:flex; gap:.5rem; align-items:center; justify-content:flex-end; margin-top:.5rem; }
    .btn { padding:.6rem 1rem; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    .btn.primary { background:#4CAF50; color:#fff; border-color:#4CAF50; }
    .btn.primary:hover { filter:brightness(.95); }
    .status { font-size:.9rem; }
    .dirty { color:#b45309; }
    .ok, .status.success { color:#2e7d32; }
    .status.error { color:#b91c1c; }

    table { width:100%; border-collapse: collapse; margin-top: .5rem; }
    th, td { border:1px solid #ddd; padding:.5rem; text-align:left; vertical-align:top; }
    th { background: var(--bg); }

    /* Pills (für Tabellen/Infos) */
    .pill {
      display:inline-block; padding: 3px 8px; border-radius: 12px;
      background:#e0f7fa; margin:2px; font-size: 12px; cursor:help;
    }

    /* TagPicker */
    .tag-input { position: relative; border:1px solid #ddd; border-radius:8px; padding:6px; display:flex; flex-wrap:wrap; gap:6px; cursor:text; background:#fff; }
    .tag-input:focus-within { outline: 3px solid rgba(14,165,233,.18); border-color:#0ea5e9; }
    .tag-chip { display:inline-flex; align-items:center; gap:6px; padding:5px 8px; border-radius:999px; background:#f3f4f6; border:1px solid #e5e7eb; font-size:12px; }
    .tag-chip[title]{ cursor:help; }
    .tag-x { font-size:12px; line-height:1; cursor:pointer; opacity:.7; }
    .tag-x:hover { opacity:1; }
    .tag-input input { border:none; outline:none; min-width:140px; flex:1; padding:4px; font:inherit; }
    .tag-suggest { position:absolute; left:0; right:0; top: calc(100% + 6px); background:#fff; border:1px solid #e5e7eb; border-radius:10px; max-height:240px; overflow:auto; box-shadow: 0 10px 30px rgba(0,0,0,.08); z-index:20; }
    .tag-sugg-item { padding:8px 10px; display:flex; justify-content:space-between; gap:8px; cursor:pointer; border-bottom:1px solid #f5f5f5; }
    .tag-sugg-item:last-child{ border-bottom:0; }
    .tag-sugg-item small{ color:#6b7280; }
    .tag-sugg-item.active, .tag-sugg-item:hover { background:#f8fafc; }
    .tag-chip.enum { background:#c8e6c9;   /* grünlich */ border-color:#a5d6a7; }
  </style>
</head>
<body>
  <h1>Anime Character Dataset</h1>
  <p class="muted">Suche links nach <b>Name (Anime)</b>, filtere per Checkbox (Validiert/Vollständig/Unvollständig), bearbeite rechts die Felder und speichere. Änderungen werden in <code>dataset/characters.jsonl</code> persistiert.</p>

  <div class="layout">
    <!-- Sidebar -->
    <div class="card">
      <div class="search-box">
        <label for="searchInput">Suche</label>
        <input id="searchInput" type="text" placeholder="Charaktername eingeben…" />

        <div class="filters">
          <label><input type="checkbox" id="flt_validated" checked style="width:auto; margin-right:.35rem;"> Validiert</label>
          <label><input type="checkbox" id="flt_complete" checked style="width:auto; margin-right:.35rem;"> Vollständig</label>
          <label><input type="checkbox" id="flt_incomplete" checked style="width:auto; margin-right:.35rem;"> Unvollständig</label>
        </div>
        <div class="legend">
          <span class="dot green"></span> Validiert
          <span class="dot yellow"></span> Vollständig (nicht validiert)
          <span class="dot red"></span> Unvollständig
        </div>

        <label for="characterSelect" style="margin-top:.5rem;">Charaktere</label>
        <select id="characterSelect" size="12"></select>
      </div>
    </div>

    <!-- Detail -->
    <div class="card">
      <div class="imgbox" style="margin-bottom: .75rem;">
        <img id="previewImg" alt="Bild" src="" />
        <div style="flex:1;">
          <label for="f_image_url">Bild-URL</label>
          <input id="f_image_url" placeholder="https://…" />
          <div class="taghint">Live-Vorschau aktualisiert sich, sobald du die URL änderst.</div>
        </div>
      </div>

      <div class="grid">
        <div>
          <label for="f_name">Name</label>
          <input id="f_name" />
        </div>
        <div>
          <label for="f_gender">Geschlecht</label>
          <input id="f_gender" />
        </div>

        <div>
          <label for="f_anime_title">Anime Titel</label>
          <input id="f_anime_title" />
        </div>
        <div>
          <label for="f_anime_year_start">Startjahr (YYYY)</label>
          <input id="f_anime_year_start" inputmode="numeric" />
        </div>

        <div>
          <label for="f_age">Alter (frei/zahl)</label>
          <input id="f_age" placeholder="z. B. 17 oder 'unbekannt'" />
        </div>
        <div>
          <label for="f_height_cm">Größe (cm oder Bereich)</label>
          <input id="f_height_cm" placeholder="z. B. 170 oder 145-180" />
        </div>

        <div>
          <label for="f_role">Rolle</label>
          <input id="f_role" placeholder="Main / Supporting" />
        </div>

        <div>
          <label for="picker_species">Spezies</label>
          <div id="picker_species" class="tag-input"></div>
        </div>

        <div>
          <label for="picker_class">Klasse/Beruf</label>
          <div id="picker_class" class="tag-input"></div>
        </div>

        <div>
          <label for="picker_hair">Haarfarbe</label>
          <div id="picker_hair" class="tag-input"></div>
        </div>

        <div>
          <label for="picker_eyes">Augenfarbe</label>
          <div id="picker_eyes" class="tag-input"></div>
        </div>

        <div>
          <label for="picker_characteristics">Charaktereigenschaften</label>
          <div id="picker_characteristics" class="tag-input"></div>
        </div>

        <div>
          <label for="picker_difficulty">Schwierigkeitsgrad</label>
          <div id="picker_difficulty" class="tag-input"></div>
        </div>

        <div>
          <label for="f_alt_names">Alternative Namen</label>
          <input id="f_alt_names" placeholder="Alternative Namen (durch , oder ; trennen)" />
        </div>

        <div>
          <label for="f_validated">Validiert?</label>
          <div>
            <input id="f_validated" type="checkbox" style="width:auto" />
            <span class="muted">Markiere, wenn geprüft ✔</span>
          </div>
        </div>
      </div>

      <div class="toolbar">
        <span id="saveStatus" class="status"></span>
        <button id="saveBtn" class="btn primary">Änderungen speichern</button>
      </div>

      <table id="charTable" style="display:none"></table>
    </div>
  </div>

  <!-- Enums importieren -->
  <script type="module">
    import {
      SPECIES_TAGS, HAIR_COLOR_TAGS, EYE_COLOR_TAGS,
      DIFFICULTY_TAGS, CLASS_TAGS, CHARACTERISTIC_TAGS
    } from './tags.js';

    // ---------- TagPicker (Multi-Select mit Vorschlägen) ----------
    class TagPicker {
      constructor(el, enumMap){
        this.root = el;
        this.enumMap = enumMap || {};   // { key: {label,description}, ... }
        this.keys = [];                 // gewählte Einträge (Keys ODER Freitext)
        this.active = -1;
        this.build();
      }
      build(){
        this.input = document.createElement('input');
        this.sugg  = document.createElement('div');
        this.sugg.className = 'tag-suggest';
        this.sugg.style.display = 'none';
        this.root.appendChild(this.input);
        this.root.appendChild(this.sugg);

        this.root.addEventListener('click', ()=> this.input.focus());
        this.input.addEventListener('input', ()=> this.renderSuggest());
        this.input.addEventListener('keydown', (e)=>{
          const items = [...this.sugg.querySelectorAll('.tag-sugg-item')];
          if (this.sugg.style.display !== 'none'){
            if (e.key === 'ArrowDown'){ e.preventDefault(); if (items.length){ this.active = (this.active+1) % items.length; this.updateActive(items); } }
            else if (e.key === 'ArrowUp'){ e.preventDefault(); if (items.length){ this.active = (this.active-1+items.length) % items.length; this.updateActive(items); } }
            else if (e.key === 'Enter'){ e.preventDefault(); if (items[this.active]) items[this.active].click(); }
            else if (e.key === 'Escape'){ this.hideSuggest(); }
          } else if (e.key === 'Enter') {
            const raw = this.input.value.trim();
            if (raw) { this.addByInput(raw); }
          }
          if (e.key === 'Backspace' && !this.input.value && this.keys.length){
            this.remove(this.keys[this.keys.length-1]);
          }
        });
        document.addEventListener('click', (e)=>{
          if (!this.root.contains(e.target)) this.hideSuggest();
        });
        this.renderChips();
      }

      // Map Label/Key → gespeicherter Key ODER Freitext (Original erhalten)
      keyByLabelOrKey(s){
        const original = String(s).trim();
        const q = original.toLowerCase();
        if (this.enumMap[q]) return q; // exakter Key
        for (const [k, v] of Object.entries(this.enumMap)) {
          if ((v.label || '').toLowerCase() === q) return k; // Label → Key
        }
        return original; // Freitext bleibt erhalten
      }
      // Ausgabe-Label
      labelOfKey(k){
        if (this.enumMap && this.enumMap[k]) return this.enumMap[k].label;
        return k; // Freitext
      }

      addByInput(raw){
        const key = this.keyByLabelOrKey(raw);
        if (!this.keys.includes(key)) {
          this.keys.push(key);
          this.renderChips();
        }
        this.input.value = '';
        this.hideSuggest();
        this.emitChange();
      }
      addKey(key){
        if (!this.keys.includes(key)) {
          this.keys.push(key);
          this.renderChips();
          this.emitChange();
        }
        this.input.value = '';
        this.hideSuggest();
      }
      remove(key){
        this.keys = this.keys.filter(k => k !== key);
        this.renderChips();
        this.emitChange();
      }
renderChips(){
  [...this.root.querySelectorAll('.tag-chip')].forEach(n => n.remove());
  this.keys.forEach(k=>{
    const chip = document.createElement('span');
    chip.className = 'tag-chip';
    if (this.enumMap && this.enumMap[k]) {
      chip.classList.add('enum'); // -> grün
    }
    chip.title = this.enumMap?.[k]?.description || '';
    chip.innerHTML = `<span>${this.labelOfKey(k)}</span><span class="tag-x" aria-label="entfernen">✕</span>`;
    chip.querySelector('.tag-x').addEventListener('click', ()=> this.remove(k));
    this.root.insertBefore(chip, this.input);
  });
}

      updateActive(items){ items.forEach((el,i)=> el.classList.toggle('active', i===this.active)); }
      renderSuggest(){
        const q = this.input.value.trim().toLowerCase();
        const all = Object.entries(this.enumMap || {});
        let list = all
          .filter(([k]) => !this.keys.includes(k))
          .filter(([k,v]) => !q || k.includes(q) || (v.label||'').toLowerCase().includes(q))
          .slice(0, 10);

        if (!list.length && q) {
          this.sugg.innerHTML = `<div class="tag-sugg-item">${this.escape(this.input.value)}<small>Freitext</small></div>`;
          this.sugg.firstChild.addEventListener('click', ()=> this.addByInput(this.input.value));
          this.sugg.style.display = 'block';
          this.active = 0;
          return;
        }
        if (!list.length){ this.hideSuggest(); return; }

        this.sugg.innerHTML = '';
        list.forEach(([k,v], i)=>{
          const div = document.createElement('div');
          div.className = 'tag-sugg-item';
          div.innerHTML = `<span>${this.escape(v.label||k)}</span><small>${this.escape(v.description||'')}</small>`;
          div.addEventListener('click', ()=> this.addKey(k));
          this.sugg.appendChild(div);
        });
        this.sugg.style.display = 'block';
        this.active = 0;
        this.updateActive([...this.sugg.querySelectorAll('.tag-sugg-item')]);
      }
      hideSuggest(){ this.sugg.style.display = 'none'; this.active = -1; }
      escape(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

      // API
      setFrom(valueArrayOrString){
        const arr = Array.isArray(valueArrayOrString)
          ? valueArrayOrString
          : (valueArrayOrString ? String(valueArrayOrString).split(/[,;]\s*/).filter(Boolean) : []);
        this.keys = [...new Set(arr.map(v => this.keyByLabelOrKey(v)))];
        this.renderChips();
        this.emitChange();
      }
      getKeys(){ return [...this.keys]; }
      onChange(fn){ this._onChange = fn; }
      emitChange(){ this._onChange && this._onChange(this.getKeys()); }
    }

    // ---------- Picker-Instanzen ----------
    const pickers = {
      species:         new TagPicker(document.getElementById('picker_species'), SPECIES_TAGS),
      hair:            new TagPicker(document.getElementById('picker_hair'), HAIR_COLOR_TAGS),
      eyes:            new TagPicker(document.getElementById('picker_eyes'), EYE_COLOR_TAGS),
      difficulty:      new TagPicker(document.getElementById('picker_difficulty'), DIFFICULTY_TAGS),
      class:           new TagPicker(document.getElementById('picker_class'), CLASS_TAGS),
      characteristics: new TagPicker(document.getElementById('picker_characteristics'), CHARACTERISTIC_TAGS),
    };

    // Optional: Hidden-Inputs synchronisieren (falls vorhanden)
    const syncHidden = (id, keys) => {
      const el = document.getElementById(id);
      if (el) el.value = keys.join('; ');
    };
    Object.entries(pickers).forEach(([name, picker])=>{
      picker.onChange(keys => syncHidden(`f_${name}_tags`, keys));
    });

    // Exporte für den Non-Module Bereich
    window.__ENUMS__ = { SPECIES_TAGS, HAIR_COLOR_TAGS, EYE_COLOR_TAGS, DIFFICULTY_TAGS, CLASS_TAGS, CHARACTERISTIC_TAGS };
    window.__PICKERS__ = pickers;
  </script>

  <!-- App-Logik -->
  <script>
    let characters = [];
    let currentChar = null;
    let dirty = false;

    const $ = (id)=> document.getElementById(id);
    const setDirty = (v=true)=> {
      dirty = v;
      const el = $("saveStatus");
      el.textContent = v ? "Ungespeicherte Änderungen…" : "Gespeichert";
      el.className = "status " + (v ? "dirty" : "ok");
    };

    function debounce(fn, ms=250) {
      let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
    }
    function toTags(str){ if (!str) return []; return String(str).split(/[,;]\s*/g).map(s=>s.trim()).filter(Boolean); }
    function fromTags(arr){ return Array.isArray(arr) ? arr.join("; ") : (arr ?? ""); }
    function asIntOrNull(v){ if (v===""||v==null) return null; const n=parseInt(String(v).trim(),10); return Number.isFinite(n)?n:null; }

    // ---- Status-Berechnung ----
    function isComplete(c){
      const required = [
        !!c?.name,
        !!c?.anime_title,
        !!c?.anime_year_start,
        !!c?.image_url,
        ( !!c?.gender || !!c?.age || (Array.isArray(c?.species_tags) && c.species_tags.length>0) ),
      ];
      return required.every(Boolean);
    }
    function getStatus(c){ if (c?.validated) return "validated"; if (isComplete(c)) return "complete"; return "incomplete"; }
    function statusStyle(status){ if (status==="validated") return "background:#c8e6c9;"; if (status==="complete") return "background:#fff9c4;"; return "background:#ffcdd2;"; }

    function renderList(options){
      const sel = $("characterSelect");
      sel.innerHTML = "";
      options.forEach(c=>{
        const opt = document.createElement("option");
        opt.value = c.character_id_mal;
        const anime = c.anime_title ? ` (${c.anime_title})` : "";
        const status = getStatus(c);
        opt.textContent = `${c.name || "—"}${anime}`;
        opt.setAttribute("style", statusStyle(status));
        sel.appendChild(opt);
      });
    }
    function applyFilters(arr){
      const showVal  = $("flt_validated").checked;
      const showCom  = $("flt_complete").checked;
      const showInc  = $("flt_incomplete").checked;
      return arr.filter(c=>{
        const st = getStatus(c);
        return (st==="validated" && showVal) || (st==="complete" && showCom) || (st==="incomplete" && showInc);
      });
    }
    function populateDropdown(filter=""){
      const q = filter.trim().toLowerCase();
      const base = !q ? characters
        : characters.filter(c =>
            (c.name||"").toLowerCase().includes(q) ||
            (c.anime_title||"").toLowerCase().includes(q) ||
            (Array.isArray(c.alt_names) && c.alt_names.some(n => String(n).toLowerCase().includes(q)))
          );
      renderList(applyFilters(base));
    }

    function fillForm(char){
      if (!char) return;
      $("previewImg").src = char.image_url || "";
      $("f_image_url").value = char.image_url ?? "";
      $("f_name").value = char.name ?? "";
      $("f_gender").value = char.gender ?? "";
      $("f_anime_title").value = char.anime_title ?? "";
      $("f_anime_year_start").value = char.anime_year_start ?? "";
      $("f_age").value = char.age ?? "";
      $("f_height_cm").value = char.height_cm ?? "";
      $("f_role").value = char.role ?? "";

      // TagPicker Prefill (Keys ODER Freitext erlaubt)
      const pickers = window.__PICKERS__;
      pickers.species.setFrom(char.species_tags ?? char.species ?? char.tags);
      pickers.hair.setFrom(char.hair_color_tags);
      pickers.eyes.setFrom(char.eye_color_tags);
      pickers.difficulty.setFrom(char.difficulty_tags);
      pickers.class.setFrom(char.class_tags);
      pickers.characteristics.setFrom(char.characteristic_tags);

      $("f_alt_names").value = fromTags(char.alt_names);
      $("f_validated").checked = !!char.validated;
      setDirty(false);
    }

    function readFormInto(char){
      const pickers = window.__PICKERS__;
      char.image_url = $("f_image_url").value || null;
      char.name = $("f_name").value || null;
      char.gender = $("f_gender").value || null;
      char.anime_title = $("f_anime_title").value || null;
      const yr = $("f_anime_year_start").value.trim();
      char.anime_year_start = yr === "" ? null : (asIntOrNull(yr) ?? yr);
      const age = $("f_age").value.trim();
      char.age = age === "" ? null : age;
      const h = $("f_height_cm").value.trim();
      char.height_cm = h === "" ? null : h;
      char.role = $("f_role").value || null;

      // TagPicker → Arrays
      char.species_tags        = pickers.species.getKeys();
      char.hair_color_tags     = pickers.hair.getKeys();
      char.eye_color_tags      = pickers.eyes.getKeys();
      char.difficulty_tags     = pickers.difficulty.getKeys();
      char.class_tags          = pickers.class.getKeys();
      char.characteristic_tags = pickers.characteristics.getKeys();

      char.alt_names = toTags($("f_alt_names").value);
      char.validated = $("f_validated").checked;
    }

    async function saveAll(){
      try {
        const resp = await fetch("/api/characters", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(characters)
        });
        if (resp.ok) {
          return { ok: true };
        }
        let message = "";
        try {
          const data = await resp.json();
          message = data?.error || data?.message || "";
        } catch (error) {
          const text = await resp.text().catch(() => "");
          message = text || "";
        }
        return { ok: false, message };
      } catch (error) {
        console.error("Speichern fehlgeschlagen:", error);
        return { ok: false, message: error?.message || "" };
      }
    }

    // Events (null-sicher)
    const addEv = (id, ev, fn) => { const el = $(id); if (el) el.addEventListener(ev, fn); };

    addEv("searchInput", "input", debounce(e => populateDropdown(e.target.value), 200));
    ["flt_validated","flt_complete","flt_incomplete"].forEach(id=>{
      addEv(id, "change", ()=> populateDropdown($("searchInput").value));
    });

    addEv("characterSelect", "change", e => {
      const id = e.target.value;
      currentChar = characters.find(c => String(c.character_id_mal) === String(id));
      fillForm(currentChar);
    });

    // Inputs → dirty & sync
    [
      "f_image_url","f_name","f_gender","f_anime_title","f_anime_year_start",
      "f_age","f_height_cm","f_role","f_validated","f_alt_names"
    ].forEach(id=>{
      const ev = id==="f_validated" ? "change" : "input";
      addEv(id, ev, ()=>{ if (currentChar){ readFormInto(currentChar); setDirty(true); }});
    });

    addEv("f_image_url", "input", e => { $("previewImg").src = e.target.value || ""; });

    addEv("saveBtn","click", async () => {
      if (currentChar) readFormInto(currentChar);
      $("saveStatus").textContent = "Speichern…";
      const result = await saveAll();
      if (result.ok) {
        setDirty(false);
        $("saveStatus").textContent = "Gespeichert";
        $("saveStatus").className = "status success";
      } else {
        const msg = result.message ? `: ${result.message}` : "";
        $("saveStatus").textContent = `Fehler beim Speichern${msg}`;
        $("saveStatus").className = "status error";
        const alertDetails = result.message ? ` ${result.message}` : "";
        alert(`Speichern nicht möglich. Bitte prüfe, ob der Bearbeitungs-Server läuft.${alertDetails}`);
      }
    });

    // Boot
    async function loadData(){
      const resp = await fetch("/api/characters");
      characters = await resp.json();

      // Normalisieren: *_tags-Felder in Arrays wandeln (inkl. class/characteristics)
      characters.forEach(c=>{
        const toArr = v => Array.isArray(v) ? v : (typeof v==="string" ? toTags(v) : (v==null ? [] : [v]));
        c.species_tags        = toArr(c.species_tags ?? c.species ?? c.tags);
        c.hair_color_tags     = toArr(c.hair_color_tags);
        c.eye_color_tags      = toArr(c.eye_color_tags);
        c.difficulty_tags     = toArr(c.difficulty_tags);
        c.class_tags          = toArr(c.class_tags);
        c.characteristic_tags = toArr(c.characteristic_tags);
      });

      populateDropdown();
      if (characters.length){
        const sel = $("characterSelect");
        if (sel && sel.options.length){
          sel.selectedIndex = 0;
          const id = sel.value;
          currentChar = characters.find(c => String(c.character_id_mal) === String(id));
          fillForm(currentChar);
        }
      }
    }
    loadData();
  </script>
</body>
</html>
