<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arena-Siege pro Champion (EUW, Riot API)</title>
  <style>
    :root { --bg:#0b1020; --card:#131a2a; --muted:#8fa1c7; --text:#e9f0ff; --accent:#6aa9ff; --bad:#ff6a6a; --good:#56d364; }
    *{box-sizing:border-box} body{margin:0;background:radial-gradient(1000px 600px at 10% -10%,#14203e 0,#0b1020 50%,#090e1a 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:28px 20px 10px; text-align:center}
    h1{margin:0 0 6px; font-size:clamp(20px,3.5vw,28px); letter-spacing:.2px}
    p.sub{margin:.25rem 0 1rem; color:var(--muted)}
    .wrap{max-width:1100px;margin:0 auto; padding:0 16px 40px}
    form.tools{display:grid;gap:12px;grid-template-columns:1fr 1fr;align-items:end;margin:18px auto 14px; max-width:980px}
    .field{display:flex;flex-direction:column; gap:6px}
    label{font-size:13px;color:var(--muted)}
    input, select{background:var(--card);border:1px solid #1e2a44;color:var(--text);padding:10px 12px;border-radius:10px;outline:none}
    input::placeholder{color:#6f7ea5}
    .row{display:flex; gap:10px; align-items:center}
    button{background:linear-gradient(180deg,#3b6dd8,#2c5ac0); border:0; color:#fff; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(59,109,216,.25)}
    button:disabled{opacity:.6; cursor:not-allowed; box-shadow:none}
    .hint{font-size:13px;color:var(--muted)}
    .status{margin:10px 0 18px; font-size:14px; color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); gap:14px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.0)); border:1px solid #1f2942; border-radius:16px; padding:14px; display:flex; gap:12px; align-items:center}
    .avatar{width:56px;height:56px;border-radius:12px; overflow:hidden; flex:0 0 auto; border:1px solid #2a395f}
    .avatar img{width:100%;height:100%;object-fit:cover; display:block}
    .title{font-weight:700; font-size:16px}
    .meta{font-size:12px; color:var(--muted)}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #28406f; margin-top:6px}
    .success{color:var(--good); border-color:#2f6b50}
    details.tips{margin:14px 0; color:var(--muted)}
    details.tips summary{cursor:pointer}
    .footer{margin-top:26px; font-size:12px; color:#6f7ea5}
    .sep{opacity:.25}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid #4d5f8f;border-top-color:#9fb7ff;border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px;margin-right:8px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{color:#ff9c9c}
    .muted{color:var(--muted)}
    .kvs{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:10px; margin:10px 0 18px}
    .kv{background:var(--card); border:1px dashed #28406f; border-radius:12px; padding:10px 12px; font-size:13px}
    code.small{background:#0e1427; padding:2px 6px; border-radius:6px; border:1px solid #223058}
  </style>
</head>
<body>
<header>
  <h1>Arena-Siege pro Champion</h1>
  <p class="sub">EUW fest eingestellt • Liest Matches & filtert auf <strong>Arena</strong> (queue 1700 / gameMode CHERRY)</p>
</header>

<div class="wrap">
  <form class="tools" id="form">
    <div class="field">
      <label for="apiKey">Riot API-Key</label>
      <input id="apiKey" type="password" placeholder="RGAPI-xxxx..." required />
      <div class="hint">Dein Key wird nur im Browser benutzt.</div>
    </div>

    <div class="field">
      <label for="gameName">Riot ID – Name</label>
      <input id="gameName" type="text" placeholder="z. B. Behamot" required />
    </div>

    <div class="field">
      <label for="tagLine">Riot ID – Tag</label>
      <input id="tagLine" type="text" placeholder="z. B. 6969 (optional)" />
      <div class="hint">Wenn gesetzt, wird Account-v1 by-riot-id verwendet.</div>
    </div>

    <div class="field">
      <label for="limit">Max. Matches durchsuchen</label>
<select id="limit">
  <option value="-1" selected>Alle Arena-Spiele (empfohlen)</option>
  <option value="200">200</option>
  <option value="500">500</option>
  <option value="1000">1000</option>
</select>

    </div>

    <div class="field">
      <label for="proxy">Optional: Proxy-Basis-URL <span class="muted">(gegen CORS)</span></label>
      <input id="proxy" type="url" placeholder="https://dein-proxy.example.com" />
      <div class="hint">Leer lassen für Direktaufrufe. Bei CORS-Fehlern Proxy nutzen (Tipp unten).</div>
    </div>

    <div class="row">
      <button id="go" type="submit">Analysieren</button>
      <button id="demo" type="button" title="Kein echter Call – zeigt nur Oberfläche">Demo-Modus</button>
    </div>
  </form>

  <div class="status" id="status"></div>

  <div class="kvs" id="kvs" hidden>
    <div class="kv"><strong>Spieler:</strong> <span id="kv-sum"></span></div>
    <div class="kv"><strong>Durchsuchte Matches:</strong> <span id="kv-scanned"></span></div>
    <div class="kv"><strong>Arena-Matches gefunden:</strong> <span id="kv-arena"></span></div>
    <div class="kv"><strong>Champions mit ≥1 Sieg:</strong> <span id="kv-unique"></span></div>
  </div>

  <div class="grid" id="grid"></div>

  <details class="tips">
    <summary>Tipps zu CORS / Proxy</summary>
    <div style="margin-top:8px">
      Browser blockieren häufig direkte Aufrufe zu <code class="small">*.api.riotgames.com</code>. Nutze dann einen dünnen Proxy (z. B. Cloudflare Worker) und reiche den <code>X-Riot-Token</code>-Header durch. Sichere ihn in der Praxis ab (Origins, Ratelimits etc.).
    </div>
  </details>

  <div class="footer">
    <span class="sep">•</span> Daten: Riot Match-v5, Account-v1, Summoner-v4, Data-Dragon <span class="sep">•</span>
  </div>
</div>

<script>
(() => {
  const els = {
    form: document.getElementById('form'),
    apiKey: document.getElementById('apiKey'),
    gameName: document.getElementById('gameName'),
    tagLine: document.getElementById('tagLine'),
    limit: document.getElementById('limit'),
    proxy: document.getElementById('proxy'),
    status: document.getElementById('status'),
    grid: document.getElementById('grid'),
    kvs: document.getElementById('kvs'),
    kvSum: document.getElementById('kv-sum'),
    kvScanned: document.getElementById('kv-scanned'),
    kvArena: document.getElementById('kv-arena'),
    kvUnique: document.getElementById('kv-unique'),
    go: document.getElementById('go'),
    demo: document.getElementById('demo')
  };

  const PLATFORM = 'euw1';    // Summoner-v4
  const REGION   = 'europe';  // Account/Match-v5
  const ARENA_QUEUE_ID = 1700;
  const ARENA_MODE = 'CHERRY';

  let ddVer = null;
  let champByKey = null;

  function setStatus(msg, spinning = false, isError = false) {
    els.status.innerHTML = (spinning ? '<span class="spinner"></span>' : '') + (isError ? '<span class="error">' + msg + '</span>' : msg);
  }
  function sleep(ms){return new Promise(res=>setTimeout(res,ms))}
  function withProxy(base, url) {
    if (!base) return url;
    const u = new URL(base);
    u.searchParams.set('up', url);
    return u.toString();
  }
  async function fetchJson(url, apiKey) {
    const res = await fetch(url, { headers: { 'X-Riot-Token': apiKey }});
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error('HTTP ' + res.status + ' – ' + text.slice(0,200));
    }
    return res.json();
  }

  async function ensureDataDragon() {
    if (ddVer && champByKey) return;
    const vers = await fetch('https://ddragon.leagueoflegends.com/api/versions.json').then(r=>r.json());
    ddVer = vers[0];
    const ddUrl = `https://ddragon.leagueoflegends.com/cdn/${ddVer}/data/en_US/champion.json`;
    const data = await fetch(ddUrl).then(r=>r.json());
    champByKey = {};
    for (const id in data.data) {
      const c = data.data[id];
      champByKey[c.key] = { id: c.id, name: c.name };
    }
  }

  function champAssetByParticipant(part) {
    const key = String(part.championId);
    if (champByKey && champByKey[key]) {
      const ddId = champByKey[key].id;
      return {
        img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${ddId}.png`,
        label: champByKey[key].name
      };
    }
    const safe = (part.championName || 'Unknown').replace(/[^A-Za-z]/g,'');
    return {
      img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${safe}.png`,
      label: part.championName || 'Unknown'
    };
  }

  // === NEU: unterstützt Riot ID (Name + Tag) ===
  async function resolvePlayer(gameName, tagLine, apiKey, proxyBase) {
    if (tagLine && tagLine.trim().length > 0) {
      // Account-v1 by-riot-id
      const accUrl = withProxy(
        proxyBase,
        `https://${REGION}.api.riotgames.com/riot/account/v1/accounts/by-riot-id/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`
      );
      const account = await fetchJson(accUrl, apiKey); // { puuid, gameName, tagLine }
      const sumByPuuidUrl = withProxy(
        proxyBase,
        `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/${encodeURIComponent(account.puuid)}`
      );
      const summoner = await fetchJson(sumByPuuidUrl, apiKey);
      return { puuid: account.puuid, display: `${account.gameName}#${account.tagLine}`, summonerName: summoner.name };
    }
    // Fallback: Summoner-v4 by-name (nur Name)
    const sumUrl = withProxy(
      proxyBase,
      `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-name/${encodeURIComponent(gameName)}`
    );
    const summoner = await fetchJson(sumUrl, apiKey);
    return { puuid: summoner.puuid, display: `${summoner.name} (ohne Tag)`, summonerName: summoner.name };
  }

  function renderResults(displayName, scanned, arenaCount, winners) {
  els.kvSum.textContent = displayName + ' • EUW';
  els.kvScanned.textContent = scanned;
  els.kvArena.textContent = arenaCount;
  els.kvUnique.textContent = winners.size;
  els.kvs.hidden = false;

  els.grid.innerHTML = '';
  const rows = Array.from(winners.entries()).sort((a,b)=>{
    const aw=a[1].wins, bw=b[1].wins;
    if (bw!==aw) return bw-aw;
    return a[0].localeCompare(b[0]);
  });

  if (rows.length === 0) {
    els.grid.innerHTML = '<div class="kv">Keine Champions mit Arena-Sieg gefunden (in den betrachteten Matches).</div>';
    return;
  }

  // === HIGHLIGHT Platz 1 ===
  const [bestChamp, bestInfo] = rows[0];
  const topCard = document.createElement('div');
  topCard.className = 'card';
  topCard.style.border = '2px solid gold';
  topCard.style.background = 'linear-gradient(180deg,#3b2b00,#1a1500)';
  topCard.innerHTML = `
    <div class="avatar" style="width:72px;height:72px;border-radius:50%;">
      <img src="${bestInfo.img}" alt="${bestChamp}" loading="lazy">
    </div>
    <div>
      <div class="title" style="font-size:20px;color:gold">🏆 Platz 1: ${bestChamp}</div>
      <div class="meta">Siege: ${bestInfo.wins} • Letzter Sieg: ${new Date(bestInfo.lastWin).toLocaleString()}</div>
      <span class="pill success">Arena ✓</span>
    </div>`;
  els.grid.appendChild(topCard);

  // === Restliche Champions ===
  for (let i=1; i<rows.length; i++) {
    const [champ, info] = rows[i];
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <div class="avatar"><img src="${info.img}" alt="${champ}" loading="lazy"></div>
      <div>
        <div class="title">${champ}</div>
        <div class="meta">Siege: ${info.wins} • Letzter Sieg: ${new Date(info.lastWin).toLocaleString()}</div>
        <span class="pill success">Arena ✓</span>
      </div>`;
    els.grid.appendChild(card);
  }
}

  async function run(apiKey, gameName, tagLine, limit, proxyBase) {
    els.grid.innerHTML = '';
    els.kvs.hidden = true;

    setStatus('Lade Data-Dragon-Katalog…', true);
    await ensureDataDragon();

    setStatus('Löse Riot ID auf…', true);
    const { puuid, display, summonerName } = await resolvePlayer(gameName.trim(), (tagLine||'').trim(), apiKey, proxyBase);

    // Match-IDs in Seiten
setStatus('Lade Arena-Match-IDs…', true);
const ids = [];
let start = 0;
const step = 100;

// Wenn du wirklich *alle* Arena-Spiele willst, lass die Schleife laufen,
// bis die API keine IDs mehr liefert.
while (true) {
  const count = Math.min(step, limit === -1 ? step : Math.max(0, Math.min(step, limit - ids.length)));
  if (limit !== -1 && ids.length >= limit) break;

  const idsUrl = withProxy(
    proxyBase,
    `https://${REGION}.api.riotgames.com/lol/match/v5/matches/by-puuid/${encodeURIComponent(puuid)}/ids` +
    `?start=${start}&count=${step}&queue=${ARENA_QUEUE_ID}`
  );

  const page = await fetchJson(idsUrl, apiKey); // -> ausschließlich Arena-IDs
  ids.push(...(limit === -1 ? page : page.slice(0, count)));

  setStatus(`Arena-IDs geladen: ${ids.length}${limit === -1 ? '' : '/' + limit}…`, true);
  if (page.length < step) break; // keine weiteren Treffer
  start += step;

  await sleep(120); // Rate-Limit schonen
}

if (ids.length === 0) {
  renderResults(display, 0, 0, new Map());
  setStatus('Keine Arena-Matches gefunden.');
  return;
}


    // Matches ziehen & filtern
    const winners = new Map();
    let arenaCount = 0;
    let scanned = 0;

    setStatus('Analysiere Matches…', true);
    for (const id of ids) {
      const mUrl = withProxy(proxyBase, `https://${REGION}.api.riotgames.com/lol/match/v5/matches/${id}`);
      try {
        const match = await fetchJson(mUrl, apiKey);
        scanned++;
        const info = match.info || {};
        const isArena = (info.queueId === ARENA_QUEUE_ID) || (info.gameMode === ARENA_MODE);
        if (!isArena) { if (scanned % 15 === 0) setStatus(`Analysiere… (${scanned}/${ids.length})`, true); await sleep(60); continue; }
        arenaCount++;
        const me = (info.participants || []).find(p => p.puuid === puuid);
        if (me && me.win) {
          const asset = champAssetByParticipant(me);
          const key = asset.label;
          if (!winners.has(key)) winners.set(key, { wins: 0, lastWin: 0, img: asset.img });
          const slot = winners.get(key);
          slot.wins += 1;
          slot.lastWin = Math.max(slot.lastWin || 0, (info.gameEndTimestamp || info.gameStartTimestamp || 0));
        }
        if (scanned % 10 === 0) setStatus(`Arena: ${arenaCount} • Fortschritt ${scanned}/${ids.length}`, true);
        await sleep(120);
      } catch (e) {
        console.warn('Match fetch failed', id, e);
        await sleep(150);
      }
    }

    renderResults(display, scanned, arenaCount, winners);
    setStatus(`Fertig. Champions mit ≥1 Arena-Sieg: ${winners.size}.`);
  }

  els.form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const apiKey = els.apiKey.value.trim();
    const gameName = els.gameName.value.trim();
    const tagLine = els.tagLine.value.trim();
    const limit = parseInt(els.limit.value, 10); // -1 bedeutet: alle Arena-IDs 
    const proxy = els.proxy.value.trim();
    if (!apiKey || !gameName) {
      setStatus('Bitte API-Key und Riot-ID-Name angeben.', false, true);
      return;
    }
    els.go.disabled = true;
    try {
      await run(apiKey, gameName, tagLine, limit, proxy || '');
    } catch (e) {
      setStatus('Fehler: ' + e.message, false, true);
    } finally {
      els.go.disabled = false;
    }
  });

  els.demo.addEventListener('click', () => {
    const winners = new Map();
    winners.set('Ahri', { wins: 3, lastWin: Date.now() - 86400000*2, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Ahri.png` });
    winners.set('Darius', { wins: 1, lastWin: Date.now() - 86400000*5, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Darius.png` });
    winners.set('Kai\'Sa', { wins: 2, lastWin: Date.now() - 3600*1000*6, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Kaisa.png` });
    els.kvs.hidden = false;
    els.kvSum.textContent = 'Beispielspieler#EUW';
    els.kvScanned.textContent = 120;
    els.kvArena.textContent = 34;
    els.kvUnique.textContent = winners.size;
    els.grid.innerHTML = '';
    for (const [name, info] of winners.entries()) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="avatar"><img src="${info.img}" alt="${name}" loading="lazy"></div>
        <div>
          <div class="title">${name}</div>
          <div class="meta">Siege: ${info.wins} • Letzter Sieg: ${new Date(info.lastWin).toLocaleString()}</div>
          <span class="pill success">Arena ✓</span>
        </div>`;
      els.grid.appendChild(card);
    }
    setStatus('Demo-Modus aktiv (keine Riot-Calls).');
  });
})();
</script>
</body>
</html>
