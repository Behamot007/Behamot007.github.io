<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arena-Statistik (EUW, Riot API) ‚Äì Gesamt & pro Champion</title>
  <style>
    :root { --bg:#0b1020; --card:#131a2a; --muted:#8fa1c7; --text:#e9f0ff; --accent:#6aa9ff; --good:#56d364; }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1000px 600px at 10% -10%,#14203e 0,#0b1020 50%,#090e1a 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:28px 20px 10px; text-align:center}
    h1{margin:0 0 6px; font-size:clamp(20px,3.5vw,28px)}
    p.sub{margin:.25rem 0 1rem; color:var(--muted)}
    .wrap{max-width:1100px;margin:0 auto; padding:0 16px 40px}
    form.tools{display:grid;gap:12px;grid-template-columns:1fr 1fr;align-items:end;margin:18px auto 14px; max-width:980px}
    .field{display:flex;flex-direction:column; gap:6px}
    label{font-size:13px;color:var(--muted)}
    input, select{background:var(--card);border:1px solid #1e2a44;color:var(--text);padding:10px 12px;border-radius:10px;outline:none}
    input::placeholder{color:#6f7ea5}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    button{background:linear-gradient(180deg,#3b6dd8,#2c5ac0); border:0; color:#fff; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(59,109,216,.25)}
    button:disabled{opacity:.6; cursor:not-allowed; box-shadow:none}
    .hint{font-size:13px;color:var(--muted)}
    .status{margin:10px 0 18px; font-size:14px; color:var(--muted)}
    .kvs{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:10px; margin:10px 0 18px}
    .kv{background:var(--card); border:1px dashed #28406f; border-radius:12px; padding:10px 12px; font-size:13px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); gap:14px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.0)); border:1px solid #1f2942; border-radius:16px; padding:14px; display:flex; gap:12px; align-items:center}
    .avatar{width:56px;height:56px;border-radius:12px; overflow:hidden; flex:0 0 auto; border:1px solid #2a395f}
    .avatar img{width:100%;height:100%;object-fit:cover; display:block}
    .title{font-weight:700; font-size:16px}
    .meta{font-size:12px; color:var(--muted)}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #28406f; margin-top:6px}
    .success{color:var(--good); border-color:#2f6b50}
    /* Highlight f√ºr alle Champions mit >=1 Top 1 */
    .winner{border:2px solid gold; background:linear-gradient(180deg,#3b2b00,#1a1500)}
    .badge{display:inline-block; margin-left:6px; padding:2px 8px; border-radius:999px; border:1px solid #6b5d28; font-size:12px; color:#ffd76a}
    .filehint{font-size:12px;color:#9ab0da}
  </style>
</head>
<body>
<header>
  <h1>Arena-Statistik (EUW)</h1>
  <p class="sub">Filtert bei der ID-Suche auf <strong>Arena</strong> (Queues 1700 & 1710) ‚Ä¢ zeigt Gesamt & pro Champion ‚Ä¢ Import/Export</p>
</header>

<div class="wrap">
  <form class="tools" id="form">
    <div class="field">
      <label for="apiKey">Riot API-Key</label>
      <input id="apiKey" type="password" placeholder="RGAPI-xxxx..." required />
      <div class="hint">Wird nur im Browser/Proxy verwendet.</div>
    </div>

    <div class="field">
      <label for="gameName">Riot ID ‚Äì Name</label>
      <input id="gameName" type="text" placeholder="z. B. Behamot" required />
    </div>

    <div class="field">
      <label for="tagLine">Riot ID ‚Äì Tag</label>
      <input id="tagLine" type="text" placeholder="z. B. 6969 (optional)" />
      <div class="hint">Wenn gesetzt, wird Account-v1 by-riot-id verwendet.</div>
    </div>

    <div class="field">
      <label for="limit">Zu ladende Arena-Spiele</label>
      <select id="limit">
        <option value="-1" selected>Alle (paginiere bis Ende)</option>
        <option value="200">200</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
      </select>
    </div>

    <div class="field">
      <label for="proxy">Proxy-Basis-URL <span class="muted">(gegen CORS)</span></label>
      <input id="proxy" type="url" placeholder="https://dein-worker.workers.dev" />
      <div class="hint">Leer lassen f√ºr Direktaufrufe. Bei CORS-Fehlern Proxy nutzen (Worker/Express).</div>
    </div>

    <!-- Import/Export -->
    <div class="field">
      <label>Datensatz Import/Export</label>
      <div class="row">
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" type="button">Importieren (.json)</button>
        <button id="exportBtn" type="button" disabled>Exportieren (.json)</button>
        <label class="row" style="gap:6px; margin-left:8px;">
          <input id="analyzeOnly" type="checkbox" />
          <span>Nur analysieren (keine neuen Fetches)</span>
        </label>
      </div>
      <div class="filehint" id="importInfo">Noch kein Datensatz importiert.</div>
    </div>

    <div class="row">
      <button id="go" type="submit">Analysieren</button>
      <button id="demo" type="button" title="UI-Vorschau ohne Riot-Calls">Demo-Modus</button>
    </div>
    <div class="hint">Top 4 = obere H√§lfte der Duos (8 Duos ‚áí ‚â§ 4, 4 Duos ‚áí ‚â§ 2). Top 1 = subteamPlacement = 1.</div>
  </form>

  <div class="status" id="status"></div>

  <div class="kvs" id="kvs" hidden>
    <div class="kv"><strong>Spieler:</strong> <span id="kv-sum"></span></div>
    <div class="kv"><strong>Gesamt Spiele:</strong> <span id="kv-games"></span></div>
    <div class="kv"><strong>Top 4:</strong> <span id="kv-top4"></span></div>
    <div class="kv"><strong>Top 1 (Wins):</strong> <span id="kv-top1"></span></div>
    <div class="kv"><strong>Top 4-Rate:</strong> <span id="kv-top4rate"></span></div>
    <div class="kv"><strong>Win-Rate:</strong> <span id="kv-winrate"></span></div>
  </div>

  <div class="grid" id="grid"></div>

  <div class="footer">
    <span class="sep">‚Ä¢</span> Daten: Riot Account-v1, Summoner-v4, Match-v5, Data-Dragon <span class="sep">‚Ä¢</span>
  </div>
</div>

<script>
(() => {
  // --- DOM refs ---
  const els = {
    form: document.getElementById('form'),
    apiKey: document.getElementById('apiKey'),
    gameName: document.getElementById('gameName'),
    tagLine: document.getElementById('tagLine'),
    limit: document.getElementById('limit'),
    proxy: document.getElementById('proxy'),
    status: document.getElementById('status'),
    kvs: document.getElementById('kvs'),
    kvSum: document.getElementById('kv-sum'),
    kvGames: document.getElementById('kv-games'),
    kvTop4: document.getElementById('kv-top4'),
    kvTop1: document.getElementById('kv-top1'),
    kvTop4rate: document.getElementById('kv-top4rate'),
    kvWinrate: document.getElementById('kv-winrate'),
    grid: document.getElementById('grid'),
    go: document.getElementById('go'),
    demo: document.getElementById('demo'),
    importBtn: document.getElementById('importBtn'),
    importFile: document.getElementById('importFile'),
    exportBtn: document.getElementById('exportBtn'),
    analyzeOnly: document.getElementById('analyzeOnly'),
    importInfo: document.getElementById('importInfo'),
  };

  // --- Consts ---
  const PLATFORM = 'euw1';    // Summoner-v4
  const REGION   = 'europe';  // Account/Match-v5
  const ARENA_QUEUES = [1700, 1710]; // Arena Queues

  // --- DDragon cache ---
  let ddVer = null;
  let champByKey = null;

  // --- Dataset state ---
  let importedDataset = null; // {version, exportedAt, queues, puuid, player, matches: [{id,info,metadata?}]}
  let lastDataset = null;     // das, was exportiert werden kann (live oder import)

  // --- Utils ---
  function setStatus(msg, spinning = false, isError = false) {
    els.status.innerHTML = (spinning ? '<span class="spinner"></span>' : '') + (isError ? '<span class="error">' + msg + '</span>' : msg);
  }
  function sleep(ms){return new Promise(res=>setTimeout(res,ms))}
  function pct(a,b){return b? (a*100/b).toFixed(1)+'%':'‚Äî'}
  function withProxy(base, url) {
    if (!base) return url;
    const u = new URL(base);
    u.searchParams.set('up', url);
    return u.toString();
  }
  async function fetchJson(url, apiKey, {retries=2}={}) {
    let lastErr;
    for (let i=0;i<=retries;i++){
      const res = await fetch(url, { headers: { 'X-Riot-Token': apiKey }});
      if (res.ok) return res.json();
      const text = await res.text().catch(()=> '');
      if (res.status === 429 || res.status === 503) {
        const retryAfter = parseInt(res.headers.get('Retry-After')||'1',10);
        await sleep((isNaN(retryAfter)?1:retryAfter)*1000);
        continue;
      }
      lastErr = new Error('HTTP ' + res.status + ' ‚Äì ' + text.slice(0,200));
      break;
    }
    throw lastErr || new Error('Request fehlgeschlagen');
  }
  function downloadJSON(filename, dataObj) {
    const blob = new Blob([JSON.stringify(dataObj, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  // --- DDragon ---
  async function ensureDataDragon() {
    if (ddVer && champByKey) return;
    const vers = await fetch('https://ddragon.leagueoflegends.com/api/versions.json').then(r=>r.json());
    ddVer = vers[0];
    const ddUrl = `https://ddragon.leagueoflegends.com/cdn/${ddVer}/data/en_US/champion.json`;
    const data = await fetch(ddUrl).then(r=>r.json());
    champByKey = {};
    for (const id in data.data) {
      const c = data.data[id];
      champByKey[c.key] = { id: c.id, name: c.name };
    }
  }
  function champAssetByParticipant(part) {
    const key = String(part.championId);
    if (champByKey && champByKey[key]) {
      const ddId = champByKey[key].id;
      return {
        img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${ddId}.png`,
        label: champByKey[key].name
      };
    }
    const safe = (part.championName || 'Unknown').replace(/[^A-Za-z]/g,'');
    return {
      img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${safe}.png`,
      label: part.championName || 'Unknown'
    };
  }

  // --- Riot ID -> PUUID ---
  async function resolvePlayer(gameName, tagLine, apiKey, proxyBase) {
    if (tagLine && tagLine.trim().length > 0) {
      const accUrl = withProxy(
        proxyBase,
        `https://${REGION}.api.riotgames.com/riot/account/v1/accounts/by-riot-id/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`
      );
      const account = await fetchJson(accUrl, apiKey);
      const sumByPuuidUrl = withProxy(
        proxyBase,
        `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/${encodeURIComponent(account.puuid)}`
      );
      const summoner = await fetchJson(sumByPuuidUrl, apiKey);
      return { puuid: account.puuid, display: `${account.gameName}#${account.tagLine}`, summonerName: summoner.name };
    }
    const sumUrl = withProxy(
      proxyBase,
      `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-name/${encodeURIComponent(gameName)}`
    );
    const summoner = await fetchJson(sumUrl, apiKey);
    return { puuid: summoner.puuid, display: `${summoner.name} (ohne Tag)`, summonerName: summoner.name };
  }

  // --- Arena-ID Fetch (1700 & 1710) ---
  async function fetchArenaMatchIds(puuid, limit, proxyBase, apiKey) {
    const step = 100;
    const all = new Set();
    for (const q of ARENA_QUEUES) {
      let start = 0;
      while (true) {
        if (limit !== -1 && all.size >= limit) break;
        const url = withProxy(
          proxyBase,
          `https://${REGION}.api.riotgames.com/lol/match/v5/matches/by-puuid/${encodeURIComponent(puuid)}/ids?start=${start}&count=${step}&queue=${q}`
        );
        const page = await fetchJson(url, apiKey);
        if (!Array.isArray(page) || page.length === 0) break;
        for (const id of page) {
          if (limit !== -1 && all.size >= limit) break;
          all.add(id);
        }
        if (page.length < step) break;
        start += step;
        await sleep(120);
      }
    }
    return Array.from(all);
  }

  // --- Platzierungslogik ---
  function getTeamCount(info) {
    const ps = info.participants || [];
    const set = new Set();
    for (const p of ps) {
      if (p.playerSubteamId != null) set.add(p.playerSubteamId);
      else if (p.subteamId != null) set.add(p.subteamId);
    }
    return set.size || (info.queueId === 1710 ? 8 : 4);
  }
  function getPlacement(me) {
    if (me && typeof me.subteamPlacement === 'number') return me.subteamPlacement;
    if (me && typeof me.placement === 'number') return me.placement;
    return null;
  }
  function isTop4(placement, teamCount) {
    if (placement == null) return false;
    const threshold = (teamCount >= 8) ? 4 : 2;
    return placement <= threshold;
  }
  function isTop1(placement) { return placement === 1; }

  // --- Analyse-Helfer (nutzt fertige Matches, ohne Live-Fetch) ---
  function analyzeMatches(matchObjs, puuid, display) {
    const totals = { games: 0, top4: 0, top1: 0 };
    const statsByChamp = new Map(); // name -> {games, top4, top1, img}
    let processed = 0;

    for (const m of matchObjs) {
      const info = m.info || {};
      const me = (info.participants || []).find(p => p.puuid === puuid);
      if (!me) continue;
      const teamCount = getTeamCount(info);
      const placement = getPlacement(me);
      if (placement == null) continue;

      totals.games += 1;
      if (isTop4(placement, teamCount)) totals.top4 += 1;
      if (isTop1(placement))            totals.top1 += 1;

      const asset = champAssetByParticipant(me);
      const key = asset.label;
      if (!statsByChamp.has(key)) statsByChamp.set(key, { games: 0, top4: 0, top1: 0, img: asset.img });
      const s = statsByChamp.get(key);
      s.games += 1;
      if (isTop4(placement, teamCount)) s.top4 += 1;
      if (isTop1(placement))            s.top1 += 1;

      processed++;
      if (processed % 100 === 0) setStatus(`Analysiert: ${processed}/${matchObjs.length}‚Ä¶`, true);
    }

    renderOverall(display, totals);
    renderPerChampion(statsByChamp);
    setStatus(`Fertig. Arena-Spiele: ${totals.games} ‚Ä¢ Top 4: ${totals.top4} ‚Ä¢ Top 1: ${totals.top1}`);
  }

  // --- Render Gesamt ---
  function renderOverall(displayName, totals) {
    els.kvSum.textContent = displayName + ' ‚Ä¢ EUW';
    els.kvGames.textContent = totals.games;
    els.kvTop4.textContent = totals.top4;
    els.kvTop1.textContent = totals.top1;
    els.kvTop4rate.textContent = pct(totals.top4, totals.games);
    els.kvWinrate.textContent = pct(totals.top1, totals.games);
    els.kvs.hidden = false;
  }

  // --- Render pro Champion (alle mit >=1 Top1 hervorheben) ---
  function renderPerChampion(statsByChamp) {
    els.grid.innerHTML = '';
    const rows = Array.from(statsByChamp.entries()).sort((a,b)=>{
      const A=a[1], B=b[1];
      if (B.top1!==A.top1) return B.top1-A.top1;
      if (B.top4!==A.top4) return B.top4-A.top4;
      if (B.games!==A.games) return B.games-A.games;
      return a[0].localeCompare(b[0]);
    });

    if (rows.length === 0) {
      els.grid.innerHTML = '<div class="kv">Keine Arena-Spiele gefunden.</div>';
      return;
    }

    for (const [champ, info] of rows) {
      const card = document.createElement('div');
      card.className = 'card' + (info.top1 > 0 ? ' winner' : '');
      card.innerHTML = `
        <div class="avatar"><img src="${info.img}" alt="${champ}" loading="lazy"></div>
        <div>
          <div class="title">${champ}${info.top1>0?` <span class="badge">üèÜ Top 1 √ó ${info.top1}</span>`:''}</div>
          <div class="meta">
            Spiele: ${info.games}
            ‚Ä¢ Top 4: ${info.top4} (${((info.top4*100/info.games)||0).toFixed(1)}%)
            ‚Ä¢ Top 1: ${info.top1} (${((info.top1*100/info.games)||0).toFixed(1)}%)
          </div>
          <span class="pill success">Arena ‚úì</span>
        </div>`;
      els.grid.appendChild(card);
    }
  }

  // --- Hauptlauf ---
  async function run(apiKey, gameName, tagLine, limit, proxyBase) {
    els.kvs.hidden = true;
    els.grid.innerHTML = '';
    setStatus('', false);

    await ensureDataDragon();

    // ANALYSE-ONLY: ohne Netz, wenn Datensatz importiert
    if (els.analyzeOnly.checked && importedDataset && Array.isArray(importedDataset.matches)) {
      const puuid = importedDataset.puuid;
      const display = importedDataset.player || 'Importierter Spieler';
      lastDataset = importedDataset;              // exportierbar
      els.exportBtn.disabled = false;
      analyzeMatches(importedDataset.matches, puuid, display);
      return;
    }

    // Live: erst PUUID holen
    setStatus('L√∂se Riot ID‚Ä¶', true);
    const { puuid, display } = await resolvePlayer(gameName.trim(), (tagLine||'').trim(), apiKey, proxyBase);

    // Arena-IDs holen
    setStatus('Lade Arena-Match-IDs‚Ä¶', true);
    const ids = await fetchArenaMatchIds(puuid, limit, proxyBase, apiKey);
    if (ids.length === 0) {
      lastDataset = {
        version: 1, exportedAt: new Date().toISOString(), queues: ARENA_QUEUES,
        puuid, player: display, count: 0, matches: []
      };
      els.exportBtn.disabled = false;
      analyzeMatches([], puuid, display);
      setStatus('Keine Arena-Matches gefunden.');
      return;
    }

    // Matches laden und gleichzeitig f√ºr Export sammeln
    const collected = []; // {id, info, metadata?}
    setStatus('Lade & analysiere Arena-Matches‚Ä¶', true);
    let processed = 0;

    for (const id of ids) {
      const mUrl = withProxy(proxyBase, `https://${REGION}.api.riotgames.com/lol/match/v5/matches/${id}`);
      try {
        const match = await fetchJson(mUrl, apiKey);
        collected.push({ id: match?.metadata?.matchId || id, info: match.info, metadata: match.metadata });
        processed++;
        if (processed % 10 === 0) setStatus(`Geladen: ${processed}/${ids.length}‚Ä¶`, true);
        await sleep(100);
      } catch (e) {
        console.warn('Match fetch failed', id, e);
        await sleep(150);
      }
    }

    // Datensatz speichern & exportierbar machen
    lastDataset = {
      version: 1,
      exportedAt: new Date().toISOString(),
      queues: ARENA_QUEUES,
      puuid,
      player: display,
      count: collected.length,
      matches: collected
    };
    els.exportBtn.disabled = false;

    // Analyse durchf√ºhren
    analyzeMatches(collected, puuid, display);
  }

  // --- Events ---
  els.form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const apiKey = els.apiKey.value.trim();
    const gameName = els.gameName.value.trim();
    const tagLine = els.tagLine.value.trim();
    const limit = parseInt(els.limit.value, 10);
    const proxy = els.proxy.value.trim();

    if (!els.analyzeOnly.checked) {
      if (!apiKey || !gameName) {
        setStatus('Bitte API-Key und Riot-ID-Name angeben.', false, true);
        return;
      }
    } else {
      // Nur analysieren: API-Key/Name entfallen, aber es muss ein Import vorliegen
      if (!importedDataset) {
        setStatus('Kein Import-Datensatz vorhanden. Bitte erst eine .json importieren oder ‚ÄûNur analysieren‚Äú abw√§hlen.', false, true);
        return;
      }
    }

    els.go.disabled = true;
    try {
      await run(apiKey, gameName, tagLine, limit, proxy || '');
    } catch (e) {
      setStatus('Fehler: ' + e.message, false, true);
    } finally {
      els.go.disabled = false;
    }
  });

  // Import
  els.importBtn.addEventListener('click', () => els.importFile.click());
  els.importFile.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      if (!obj || !Array.isArray(obj.matches)) throw new Error('Ung√ºltiges Format: "matches" fehlt');
      importedDataset = obj;
      els.importInfo.textContent = `Importiert: ${obj.player || 'Unbekannt'} ‚Ä¢ Matches: ${obj.count ?? obj.matches.length} ‚Ä¢ Exportiert am: ${obj.exportedAt || '‚Äî'}`;
      els.exportBtn.disabled = false; // Re-Export erlauben
      setStatus('Datensatz importiert. Du kannst ‚ÄûNur analysieren‚Äú aktivieren und direkt starten.');
    } catch (err) {
      setStatus('Import fehlgeschlagen: ' + err.message, false, true);
      importedDataset = null;
      els.importInfo.textContent = 'Import fehlgeschlagen.';
    } finally {
      // Reset, damit gleiche Datei erneut w√§hlbar ist
      e.target.value = '';
    }
  });

  // Export
  els.exportBtn.addEventListener('click', () => {
    if (!lastDataset) {
      setStatus('Nichts zu exportieren ‚Äì bitte zuerst Matches laden oder einen Datensatz importieren.', false, true);
      return;
    }
    const nameSafe = (lastDataset.player || 'dataset').replace(/[^A-Za-z0-9_\-#]+/g,'_');
    downloadJSON(`arena_dataset_${nameSafe}.json`, lastDataset);
    setStatus('Datensatz exportiert.');
  });

  // Demo
  els.demo.addEventListener('click', () => {
    const totals = { games: 42, top4: 28, top1: 10 };
    const statsByChamp = new Map();
    statsByChamp.set('Ahri',   { games: 8, top4: 6, top1: 3, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Ahri.png` });
    statsByChamp.set('Darius', { games: 5, top4: 3, top1: 2, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Darius.png` });
    statsByChamp.set('Kaisa',  { games: 7, top4: 5, top1: 0, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Kaisa.png` });
    renderOverall('Demo#EUW', totals);
    renderPerChampion(statsByChamp);
    // Demo-Exportdaten
    lastDataset = {
      version: 1, exportedAt: new Date().toISOString(), queues: ARENA_QUEUES,
      puuid: 'demo-puuid', player: 'Demo#EUW', count: 3,
      matches: [
        { id: 'DEMO_1', info: { participants: [] } },
        { id: 'DEMO_2', info: { participants: [] } },
        { id: 'DEMO_3', info: { participants: [] } },
      ]
    };
    els.exportBtn.disabled = false;
    setStatus('Demo-Modus (keine Riot-Calls).');
  });
})();
</script>
</body>
</html>
