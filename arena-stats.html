<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arena-Statistik (EUW, Riot API) – Gesamt & pro Champion</title>
  <link rel="stylesheet" href="assets/css/base.css" />
  <link rel="stylesheet" href="assets/css/pages/arena-stats.css" />
</head>
<body>
<header>
  <h1>Arena-Statistik (EUW)</h1>
  <p class="sub">Filtert bei der ID-Suche auf <strong>Arena</strong> (Queues 1700, 1701, 1702, 1710, 1711) • zeigt Gesamt & pro Champion • Import/Export</p>
</header>

<div class="wrap">
  <form class="tools" id="form">
    <div class="field notice">
      <label>Riot API-Key</label>
      <div class="callout">
        <p>Der Key wird automatisch aus der <a href="config.html" target="_blank" rel="noopener">Konfiguration</a> übernommen.</p>
        <p class="status-line">Status: <span id="keyStatus">–</span></p>
      </div>
    </div>

    <div class="field">
      <label for="gameName">Riot ID – Name</label>
      <input id="gameName" type="text" placeholder="z. B. Behamot" required />
    </div>

    <div class="field">
      <label for="tagLine">Riot ID – Tag</label>
      <input id="tagLine" type="text" placeholder="z. B. 6969 (optional)" />
      <div class="hint">Wenn gesetzt, wird Account-v1 by-riot-id verwendet.</div>
    </div>

    <div class="field">
      <label for="limit">Zu ladende Arena-Spiele</label>
      <select id="limit">
        <option value="-1" selected>Alle (paginiere bis Ende)</option>
        <option value="200">200</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
      </select>
    </div>

    <!-- Import/Export -->
    <div class="field">
      <label>Datensatz Import/Export</label>
      <div class="row">
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <button id="importBtn" type="button">Importieren (.json)</button>
        <button id="exportBtn" type="button" disabled>Exportieren (.json)</button>
      </div>
      <div class="filehint" id="importInfo">Noch kein Datensatz importiert.</div>
    </div>

    <div class="row">
      <button id="go" type="submit">Analysieren</button>
      <button id="demo" type="button" title="UI-Vorschau ohne Riot-Calls">Demo-Modus</button>
    </div>
    <div class="hint">Top 4 = obere Hälfte der Duos (8 Duos ⇒ ≤ 4, 4 Duos ⇒ ≤ 2). Top 1 = subteamPlacement = 1.</div>
  </form>

  <div class="status" id="status"></div>

  <div class="info-callout">
    <strong>Match-History:</strong> Detaillierte Spielverläufe findest du im
    <a href="arena-match-history.html" target="_blank" rel="noopener">Arena Match Analyzer</a>.
  </div>

  <div class="kvs" id="kvs" hidden>
    <div class="kv"><strong>Spieler:</strong> <span id="kv-sum"></span></div>
    <div class="kv"><strong>Gesamt Spiele:</strong> <span id="kv-games"></span></div>
    <div class="kv"><strong>Top 4:</strong> <span id="kv-top4"></span></div>
    <div class="kv"><strong>Top 1 (Wins):</strong> <span id="kv-top1"></span></div>
    <div class="kv"><strong>Top 4-Rate:</strong> <span id="kv-top4rate"></span></div>
    <div class="kv"><strong>Win-Rate:</strong> <span id="kv-winrate"></span></div>
  </div>

  <div class="advanced" id="advanced" hidden>
    <details>
      <summary>Erweiterte Gesamtstatistiken</summary>
      <div class="advanced-grid">
        <div class="kv"><strong>Ø Platzierung:</strong> <span id="adv-avg-placement">—</span></div>
        <div class="kv"><strong>Beste Platzierung:</strong> <span id="adv-best-placement">—</span></div>
        <div class="kv"><strong>Schlechteste Platzierung:</strong> <span id="adv-worst-placement">—</span></div>
        <div class="kv"><strong>Ø Kills:</strong> <span id="adv-avg-kills">—</span></div>
        <div class="kv"><strong>Ø Deaths:</strong> <span id="adv-avg-deaths">—</span></div>
        <div class="kv"><strong>Ø Assists:</strong> <span id="adv-avg-assists">—</span></div>
        <div class="kv"><strong>Ø KDA:</strong> <span id="adv-avg-kda">—</span></div>
        <div class="kv"><strong>Ø Schaden:</strong> <span id="adv-avg-damage">—</span></div>
        <div class="kv"><strong>Max Schaden:</strong> <span id="adv-max-damage">—</span></div>
        <div class="kv"><strong>Gesamt Schaden:</strong> <span id="adv-total-damage">—</span></div>
        <div class="kv"><strong>Ø Gold:</strong> <span id="adv-avg-gold">—</span></div>
        <div class="kv"><strong>Max Gold:</strong> <span id="adv-max-gold">—</span></div>
        <div class="kv"><strong>Ø CS:</strong> <span id="adv-avg-cs">—</span></div>
        <div class="kv"><strong>Max CS:</strong> <span id="adv-max-cs">—</span></div>
        <div class="kv"><strong>Ø Dauer:</strong> <span id="adv-avg-duration">—</span></div>
        <div class="kv"><strong>Längstes Spiel:</strong> <span id="adv-longest-duration">—</span></div>
        <div class="kv"><strong>Kürzestes Spiel:</strong> <span id="adv-shortest-duration">—</span></div>
        <div class="kv"><strong>Spiele ≥ 10 Kills:</strong> <span id="adv-highkill-games">—</span></div>
        <div class="kv"><strong>Spiele ≥ 30k Schaden:</strong> <span id="adv-highdamage-games">—</span></div>
        <div class="kv"><strong>Spiele ohne Tode:</strong> <span id="adv-nodeath-games">—</span></div>
      </div>
    </details>
  </div>

  <section class="section" id="mateSection" hidden>
    <div class="section-header">
      <h2>Mitspieler</h2>
      <label class="mates-input">Min. gemeinsame Spiele
        <input id="mateMin" type="number" min="1" value="3" />
      </label>
    </div>
    <div class="mate-content" id="mateContent"></div>
  </section>

  <div class="grid" id="grid"></div>

  <div class="footer">
    <span class="sep">•</span> Daten: Riot Account-v1, Summoner-v4, Match-v5, Data-Dragon <span class="sep">•</span>
  </div>
</div>

<script>
(() => {
  const RIOT_STORAGE_KEY = 'RIOT_API_KEY';
  // --- DOM refs ---
  const els = {
    form: document.getElementById('form'),
    keyStatus: document.getElementById('keyStatus'),
    gameName: document.getElementById('gameName'),
    tagLine: document.getElementById('tagLine'),
    limit: document.getElementById('limit'),
    status: document.getElementById('status'),
    kvs: document.getElementById('kvs'),
    kvSum: document.getElementById('kv-sum'),
    kvGames: document.getElementById('kv-games'),
    kvTop4: document.getElementById('kv-top4'),
    kvTop1: document.getElementById('kv-top1'),
    kvTop4rate: document.getElementById('kv-top4rate'),
    kvWinrate: document.getElementById('kv-winrate'),
    grid: document.getElementById('grid'),
    go: document.getElementById('go'),
    demo: document.getElementById('demo'),
    importBtn: document.getElementById('importBtn'),
    importFile: document.getElementById('importFile'),
    exportBtn: document.getElementById('exportBtn'),
    importInfo: document.getElementById('importInfo'),
    advanced: document.getElementById('advanced'),
    advAvgPlacement: document.getElementById('adv-avg-placement'),
    advBestPlacement: document.getElementById('adv-best-placement'),
    advWorstPlacement: document.getElementById('adv-worst-placement'),
    advAvgKills: document.getElementById('adv-avg-kills'),
    advAvgDeaths: document.getElementById('adv-avg-deaths'),
    advAvgAssists: document.getElementById('adv-avg-assists'),
    advAvgKda: document.getElementById('adv-avg-kda'),
    advAvgDamage: document.getElementById('adv-avg-damage'),
    advMaxDamage: document.getElementById('adv-max-damage'),
    advTotalDamage: document.getElementById('adv-total-damage'),
    advAvgGold: document.getElementById('adv-avg-gold'),
    advMaxGold: document.getElementById('adv-max-gold'),
    advAvgCs: document.getElementById('adv-avg-cs'),
    advMaxCs: document.getElementById('adv-max-cs'),
    advAvgDuration: document.getElementById('adv-avg-duration'),
    advLongestDuration: document.getElementById('adv-longest-duration'),
    advShortestDuration: document.getElementById('adv-shortest-duration'),
    advHighkillGames: document.getElementById('adv-highkill-games'),
    advHighdamageGames: document.getElementById('adv-highdamage-games'),
    advNodeathGames: document.getElementById('adv-nodeath-games'),
    mateSection: document.getElementById('mateSection'),
    mateMin: document.getElementById('mateMin'),
    mateContent: document.getElementById('mateContent'),
  };

  function getStoredApiKey() {
    return (localStorage.getItem(RIOT_STORAGE_KEY) || '').trim();
  }

  function updateKeyStatus() {
    if (!els.keyStatus) return;
    const key = getStoredApiKey();
    els.keyStatus.textContent = key ? 'Gefunden' : 'Nicht gesetzt';
    els.keyStatus.className = key ? 'status-ok' : 'status-missing';
  }

  updateKeyStatus();
  if (!getStoredApiKey()) {
    setStatus('Kein Riot API-Key gefunden. Bitte in der Konfiguration hinterlegen.', false, true);
    setTimeout(() => {
      alert('Kein Riot API-Key hinterlegt. Öffne die Konfiguration und trage den Key ein.');
    }, 150);
  }
  window.addEventListener('storage', evt => {
    if (evt.key === RIOT_STORAGE_KEY) {
      updateKeyStatus();
    }
  });

  // --- Consts ---
  const PLATFORM = 'euw1';    // Summoner-v4
  const REGION   = 'europe';  // Account/Match-v5
  const ARENA_QUEUES = [1700, 1701, 1702, 1710, 1711]; // Arena Queues (inkl. frühere Varianten)
  const nf0 = new Intl.NumberFormat('de-DE');
  const nf1 = new Intl.NumberFormat('de-DE', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  const nf2 = new Intl.NumberFormat('de-DE', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  // --- DDragon cache ---
  let ddVer = null;
  let champByKey = null;

  // --- Dataset state ---
  let importedDataset = null; // {version, exportedAt, queues, puuid, player, matches: [{id,info,metadata?}]}
  let lastDataset = null;     // das, was exportiert werden kann (live oder import)
  let lastTeammateStats = null;

  // --- Utils ---
  function setStatus(msg, spinning = false, isError = false) {
    els.status.innerHTML = (spinning ? '<span class="spinner"></span>' : '') + (isError ? '<span class="error">' + msg + '</span>' : msg);
  }
  function sleep(ms){return new Promise(res=>setTimeout(res,ms))}
  function pct(a,b){return b? (a*100/b).toFixed(1)+'%':'—'}
  function formatDuration(seconds) {
    if (!seconds) return '—';
    const total = Math.max(0, seconds);
    const mins = Math.floor(total / 60);
    const secs = Math.round(total % 60);
    return `${mins}m ${secs.toString().padStart(2,'0')}s`;
  }
  function ensureSeconds(duration) {
    if (!duration) return 0;
    return duration > 100000 ? duration / 1000 : duration;
  }
  function formatDate(ts) {
    if (!ts) return '—';
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return '—';
    return d.toLocaleDateString('de-DE', { day:'2-digit', month:'2-digit', year:'numeric' });
  }
  function playerLabel(part) {
    if (!part) return 'Unbekannt';
    if (part.riotIdGameName) {
      if (part.riotIdTagline && part.riotIdTagline !== '0') return `${part.riotIdGameName}#${part.riotIdTagline}`;
      return part.riotIdGameName;
    }
    if (part.gameName) {
      return part.tagLine ? `${part.gameName}#${part.tagLine}` : part.gameName;
    }
    if (part.summonerName) return part.summonerName;
    if (part.puuid) return part.puuid.slice(0, 8);
    return 'Unbekannt';
  }
  function getTeamIdentifier(part) {
    if (!part) return 'team-unknown';
    if (part.playerSubteamId != null) return `subteam-${part.playerSubteamId}`;
    if (part.subteamId != null) return `subteam-${part.subteamId}`;
    if (part.teamId != null) return `team-${part.teamId}`;
    return `solo-${part.puuid || Math.random().toString(36).slice(2,7)}`;
  }
  function escapeHtml(str) {
    return String(str ?? '').replace(/[&<>"']/g, (ch) => {
      switch (ch) {
        case '&': return '&amp;';
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '"': return '&quot;';
        case '\'': return '&#39;';
        default: return ch;
      }
    });
  }
  function percentText(count, total) {
    if (!total) return '—';
    return nf1.format((count * 100) / total) + '%';
  }
  async function fetchJson(url, apiKey, {retries=2}={}) {
    let lastErr;
    for (let i=0;i<=retries;i++){
      const res = await fetch(url, { headers: { 'X-Riot-Token': apiKey }});
      if (res.ok) return res.json();
      const text = await res.text().catch(()=> '');
      if (res.status === 429 || res.status === 503) {
        const retryAfter = parseInt(res.headers.get('Retry-After')||'1',10);
        await sleep((isNaN(retryAfter)?1:retryAfter)*1000);
        continue;
      }
      lastErr = new Error('HTTP ' + res.status + ' – ' + text.slice(0,200));
      break;
    }
    throw lastErr || new Error('Request fehlgeschlagen');
  }
  function downloadJSON(filename, dataObj) {
    const blob = new Blob([JSON.stringify(dataObj, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  // --- DDragon ---
  async function ensureDataDragon() {
    if (ddVer && champByKey) return;
    const vers = await fetch('https://ddragon.leagueoflegends.com/api/versions.json').then(r=>r.json());
    ddVer = vers[0];
    const ddUrl = `https://ddragon.leagueoflegends.com/cdn/${ddVer}/data/en_US/champion.json`;
    const data = await fetch(ddUrl).then(r=>r.json());
    champByKey = {};
    for (const id in data.data) {
      const c = data.data[id];
      champByKey[c.key] = { id: c.id, name: c.name };
    }
  }
  function champAssetByParticipant(part) {
    const key = String(part.championId);
    if (champByKey && champByKey[key]) {
      const ddId = champByKey[key].id;
      return {
        img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${ddId}.png`,
        label: champByKey[key].name
      };
    }
    const safe = (part.championName || 'Unknown').replace(/[^A-Za-z]/g,'');
    return {
      img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${safe}.png`,
      label: part.championName || 'Unknown'
    };
  }

  // --- Riot ID -> PUUID ---
  async function resolvePlayer(gameName, tagLine, apiKey) {
    if (tagLine && tagLine.trim().length > 0) {
      const accUrl = `https://${REGION}.api.riotgames.com/riot/account/v1/accounts/by-riot-id/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`;
      const account = await fetchJson(accUrl, apiKey);
      const sumByPuuidUrl = `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/${encodeURIComponent(account.puuid)}`;
      const summoner = await fetchJson(sumByPuuidUrl, apiKey);
      return { puuid: account.puuid, display: `${account.gameName}#${account.tagLine}`, summonerName: summoner.name };
    }
    const sumUrl = `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-name/${encodeURIComponent(gameName)}`;
    const summoner = await fetchJson(sumUrl, apiKey);
    return { puuid: summoner.puuid, display: `${summoner.name} (ohne Tag)`, summonerName: summoner.name };
  }

  // --- Arena-ID Fetch ---
  async function fetchArenaMatchIds(puuid, limit, apiKey) {
    const step = 100;
    const all = new Set();
    for (const q of ARENA_QUEUES) {
      let start = 0;
      while (true) {
        if (limit !== -1 && all.size >= limit) break;
        const url = `https://${REGION}.api.riotgames.com/lol/match/v5/matches/by-puuid/${encodeURIComponent(puuid)}/ids?start=${start}&count=${step}&queue=${q}`;
        const page = await fetchJson(url, apiKey);
        if (!Array.isArray(page) || page.length === 0) break;
        for (const id of page) {
          if (limit !== -1 && all.size >= limit) break;
          all.add(id);
        }
        if (page.length < step) break;
        start += step;
        await sleep(120);
      }
    }
    return Array.from(all);
  }

  // --- Platzierungslogik ---
  function getTeamCount(info) {
    const ps = info.participants || [];
    const set = new Set();
    for (const p of ps) {
      if (p.playerSubteamId != null) set.add(p.playerSubteamId);
      else if (p.subteamId != null) set.add(p.subteamId);
    }
    return set.size || (info.queueId >= 1710 ? 8 : 4);
  }
  function getPlacement(me) {
    if (me && typeof me.subteamPlacement === 'number') return me.subteamPlacement;
    if (me && typeof me.placement === 'number') return me.placement;
    return null;
  }
  function isTop4(placement, teamCount) {
    if (placement == null) return false;
    const threshold = (teamCount >= 8) ? 4 : 2;
    return placement <= threshold;
  }
  function isTop1(placement) { return placement === 1; }

  // --- Analyse-Helfer (nutzt fertige Matches, ohne Live-Fetch) ---
  function analyzeMatches(matchObjs, puuid, display) {
    const totals = {
      games: 0,
      top4: 0,
      top1: 0,
      kills: 0,
      deaths: 0,
      assists: 0,
      damage: 0,
      gold: 0,
      cs: 0,
      duration: 0,
      placementSum: 0,
      bestPlacement: null,
      worstPlacement: null,
      maxDamage: 0,
      maxGold: 0,
      maxKills: 0,
      maxCs: 0,
      longestDuration: 0,
      shortestDuration: null,
      highKillGames: 0,
      highDamageGames: 0,
      noDeathGames: 0,
    };
    const statsByChamp = new Map();
    const teammateStats = new Map();
    let processed = 0;

    for (const m of matchObjs) {
      const info = m.info || {};
      const participants = info.participants || [];
      if (!participants.length) continue;
      const me = participants.find(p => p.puuid === puuid);
      if (!me) continue;

      const teamCount = getTeamCount(info);
      const placement = getPlacement(me);
      if (placement == null) continue;

      const kills = me.kills || 0;
      const deaths = me.deaths || 0;
      const assists = me.assists || 0;
      const damage = me.totalDamageDealtToChampions || 0;
      const gold = me.goldEarned || 0;
      const cs = (me.totalMinionsKilled || 0) + (me.neutralMinionsKilled || 0);
      const durationSeconds = ensureSeconds(info.gameDuration || info.gameDurationInSeconds || 0);
      const win = isTop1(placement);
      const top4 = isTop4(placement, teamCount);

      totals.games += 1;
      if (top4) totals.top4 += 1;
      if (win) totals.top1 += 1;
      totals.kills += kills;
      totals.deaths += deaths;
      totals.assists += assists;
      totals.damage += damage;
      totals.gold += gold;
      totals.cs += cs;
      totals.duration += durationSeconds;
      totals.placementSum += placement;
      totals.bestPlacement = totals.bestPlacement == null ? placement : Math.min(totals.bestPlacement, placement);
      totals.worstPlacement = totals.worstPlacement == null ? placement : Math.max(totals.worstPlacement, placement);
      totals.maxDamage = Math.max(totals.maxDamage, damage);
      totals.maxGold = Math.max(totals.maxGold, gold);
      totals.maxKills = Math.max(totals.maxKills, kills);
      totals.maxCs = Math.max(totals.maxCs, cs);
      totals.longestDuration = Math.max(totals.longestDuration, durationSeconds);
      totals.shortestDuration = totals.shortestDuration == null ? durationSeconds : Math.min(totals.shortestDuration, durationSeconds);
      if (kills >= 10) totals.highKillGames += 1;
      if (damage >= 30000) totals.highDamageGames += 1;
      if (deaths === 0) totals.noDeathGames += 1;

      const asset = champAssetByParticipant(me);
      const key = asset.label;
      if (!statsByChamp.has(key)) {
        statsByChamp.set(key, {
          games: 0,
          top4: 0,
          top1: 0,
          img: asset.img,
          kills: 0,
          deaths: 0,
          assists: 0,
          damage: 0,
          gold: 0,
          cs: 0,
          placementSum: 0,
          bestPlacement: null,
          worstPlacement: null,
          matches: [],
        });
      }
      const champStats = statsByChamp.get(key);
      champStats.games += 1;
      if (top4) champStats.top4 += 1;
      if (win) champStats.top1 += 1;
      champStats.kills += kills;
      champStats.deaths += deaths;
      champStats.assists += assists;
      champStats.damage += damage;
      champStats.gold += gold;
      champStats.cs += cs;
      champStats.placementSum += placement;
      champStats.bestPlacement = champStats.bestPlacement == null ? placement : Math.min(champStats.bestPlacement, placement);
      champStats.worstPlacement = champStats.worstPlacement == null ? placement : Math.max(champStats.worstPlacement, placement);

      const teams = new Map();
      participants.forEach((part) => {
        const teamKey = getTeamIdentifier(part);
        if (!teams.has(teamKey)) {
          const numeric = part.playerSubteamId ?? part.subteamId ?? part.teamId ?? null;
          teams.set(teamKey, { key: teamKey, numericId: numeric, placement: getPlacement(part), participants: [] });
        }
        const teamObj = teams.get(teamKey);
        if (teamObj.placement == null) teamObj.placement = getPlacement(part);
        const partAsset = champAssetByParticipant(part);
        teamObj.participants.push({
          puuid: part.puuid,
          name: playerLabel(part),
          champion: partAsset.label,
          championImg: partAsset.img,
          kills: part.kills || 0,
          deaths: part.deaths || 0,
          assists: part.assists || 0,
          isMain: part.puuid === puuid,
        });
      });

      const myTeamKey = getTeamIdentifier(me);
      const teamsList = Array.from(teams.values()).map((team) => {
        team.isSelf = (team.key === myTeamKey);
        return team;
      }).sort((a, b) => {
        if (a.placement != null && b.placement != null) return a.placement - b.placement;
        if (a.placement != null) return -1;
        if (b.placement != null) return 1;
        const aId = a.numericId ?? 0;
        const bId = b.numericId ?? 0;
        return aId - bId;
      });

      teamsList.forEach((team, idx) => {
        team.display = team.numericId != null ? team.numericId : idx + 1;
      });

      const myTeam = teamsList.find(team => team.isSelf);
      const teammates = myTeam ? myTeam.participants.filter(p => !p.isMain) : [];

      const matchEntry = {
        id: m.id,
        timestamp: info.gameCreation || info.gameStartTimestamp || 0,
        placement,
        teamCount: teamsList.length || teamCount,
        win,
        top4,
        kills,
        deaths,
        assists,
        kda: (kills + assists) / Math.max(1, deaths),
        damage,
        gold,
        cs,
        duration: durationSeconds,
        teams: teamsList,
        teammates,
      };

      champStats.matches.push(matchEntry);

      for (const mate of teammates) {
        const mateKey = mate.puuid || mate.name;
        if (!mateKey) continue;
        if (!teammateStats.has(mateKey)) {
          teammateStats.set(mateKey, { puuid: mate.puuid, name: mate.name, games: 0, wins: 0, top4: 0, champions: new Map(), lastSeen: 0 });
        }
        const entry = teammateStats.get(mateKey);
        entry.name = mate.name;
        entry.games += 1;
        if (win) entry.wins += 1;
        if (top4) entry.top4 += 1;
        entry.lastSeen = Math.max(entry.lastSeen, matchEntry.timestamp || 0);
        const champLabel = mate.champion;
        entry.champions.set(champLabel, (entry.champions.get(champLabel) || 0) + 1);
      }

      processed++;
      if (processed % 100 === 0) setStatus(`Analysiert: ${processed}/${matchObjs.length}…`, true);
    }

    for (const champ of statsByChamp.values()) {
      champ.matches.sort((a, b) => b.timestamp - a.timestamp);
    }

    renderOverall(display, totals);
    renderAdvancedTotals(totals);
    renderPerChampion(statsByChamp);
    lastTeammateStats = teammateStats;
    renderTeammates(teammateStats);
    setStatus(`Fertig. Arena-Spiele: ${totals.games} • Top 4: ${totals.top4} • Top 1: ${totals.top1} • <a href="arena-match-history.html" target="_blank" rel="noopener">Arena Match Analyzer öffnen</a>`);
  }

  // --- Render Gesamt ---
  function renderOverall(displayName, totals) {
    els.kvSum.textContent = displayName + ' • EUW';
    els.kvGames.textContent = totals.games;
    els.kvTop4.textContent = totals.top4;
    els.kvTop1.textContent = totals.top1;
    els.kvTop4rate.textContent = pct(totals.top4, totals.games);
    els.kvWinrate.textContent = pct(totals.top1, totals.games);
    els.kvs.hidden = false;
  }

  function renderAdvancedTotals(totals) {
    if (!totals || !totals.games) {
      els.advanced.hidden = true;
      return;
    }
    els.advanced.hidden = false;
    const avgPlacement = totals.games ? totals.placementSum / totals.games : 0;
    const avgKills = totals.games ? totals.kills / totals.games : 0;
    const avgDeaths = totals.games ? totals.deaths / totals.games : 0;
    const avgAssists = totals.games ? totals.assists / totals.games : 0;
    const avgDamage = totals.games ? totals.damage / totals.games : 0;
    const avgGold = totals.games ? totals.gold / totals.games : 0;
    const avgCs = totals.games ? totals.cs / totals.games : 0;
    const avgDuration = totals.games ? totals.duration / totals.games : 0;
    const avgKda = (totals.kills + totals.assists) / Math.max(1, totals.deaths);
    els.advAvgPlacement.textContent = nf1.format(avgPlacement);
    els.advBestPlacement.textContent = totals.bestPlacement != null ? totals.bestPlacement : '—';
    els.advWorstPlacement.textContent = totals.worstPlacement != null ? totals.worstPlacement : '—';
    els.advAvgKills.textContent = nf1.format(avgKills);
    els.advAvgDeaths.textContent = nf1.format(avgDeaths);
    els.advAvgAssists.textContent = nf1.format(avgAssists);
    els.advAvgKda.textContent = nf2.format(avgKda);
    els.advAvgDamage.textContent = nf0.format(Math.round(avgDamage));
    els.advMaxDamage.textContent = nf0.format(Math.round(totals.maxDamage));
    els.advTotalDamage.textContent = nf0.format(Math.round(totals.damage));
    els.advAvgGold.textContent = nf0.format(Math.round(avgGold));
    els.advMaxGold.textContent = nf0.format(Math.round(totals.maxGold));
    els.advAvgCs.textContent = nf1.format(avgCs);
    els.advMaxCs.textContent = nf1.format(totals.maxCs);
    els.advAvgDuration.textContent = formatDuration(avgDuration);
    els.advLongestDuration.textContent = totals.longestDuration ? formatDuration(totals.longestDuration) : '—';
    els.advShortestDuration.textContent = (totals.shortestDuration != null) ? formatDuration(totals.shortestDuration) : '—';
    els.advHighkillGames.textContent = `${totals.highKillGames} (${percentText(totals.highKillGames, totals.games)})`;
    els.advHighdamageGames.textContent = `${totals.highDamageGames} (${percentText(totals.highDamageGames, totals.games)})`;
    els.advNodeathGames.textContent = `${totals.noDeathGames} (${percentText(totals.noDeathGames, totals.games)})`;
  }

  // --- Render pro Champion ---
  function renderPerChampion(statsByChamp) {
    els.grid.innerHTML = '';
    const rows = Array.from(statsByChamp.entries()).sort((a,b)=>{
      const A=a[1], B=b[1];
      if (B.top1!==A.top1) return B.top1-A.top1;
      if (B.top4!==A.top4) return B.top4-A.top4;
      if (B.games!==A.games) return B.games-A.games;
      return a[0].localeCompare(b[0]);
    });

    if (rows.length === 0) {
      els.grid.innerHTML = '<div class="kv">Keine Arena-Spiele gefunden.</div>';
      return;
    }

    for (const [champ, info] of rows) {
      const card = document.createElement('div');
      card.className = 'card' + (info.top1 > 0 ? ' winner' : '');
      const top4Rate = percentText(info.top4, info.games);
      const winRate = percentText(info.top1, info.games);
      const avgPlacement = info.games ? nf1.format(info.placementSum / info.games) : '—';
      const avgKills = info.games ? nf1.format(info.kills / info.games) : '—';
      const avgDeaths = info.games ? nf1.format(info.deaths / info.games) : '—';
      const avgAssists = info.games ? nf1.format(info.assists / info.games) : '—';
      const avgDamage = info.games ? nf0.format(Math.round(info.damage / info.games)) : '—';
      const avgGold = info.games ? nf0.format(Math.round(info.gold / info.games)) : '—';
      const avgCs = info.games ? nf1.format(info.cs / info.games) : '—';
      const kda = info.deaths ? (info.kills + info.assists) / Math.max(1, info.deaths) : (info.kills + info.assists);
      const badge = info.top1 > 0 ? ` <span class="badge">Top 1 × ${info.top1}</span>` : '';
      const matches = Array.isArray(info.matches) ? info.matches : [];
      const lastMatch = matches[0];
      const firstMatch = matches.length ? matches[matches.length - 1] : null;
      const lastSeen = lastMatch ? formatDate(lastMatch.timestamp) : '—';
      const firstSeen = firstMatch ? formatDate(firstMatch.timestamp) : '—';
      const lastResult = lastMatch ? (lastMatch.win ? 'Sieg' : 'Niederlage') : '—';
      const mateCounts = new Map();
      for (const match of matches) {
        if (!match || !Array.isArray(match.teammates)) continue;
        for (const mate of match.teammates) {
          const name = mate && mate.name ? mate.name : (mate && mate.puuid ? mate.puuid.slice(0, 8) : 'Unbekannt');
          mateCounts.set(name, (mateCounts.get(name) || 0) + 1);
        }
      }
      let favMate = '—';
      if (mateCounts.size) {
        const [topName, topCount] = Array.from(mateCounts.entries()).sort((a, b) => b[1] - a[1])[0];
        favMate = `${topName} (${topCount})`;
      }
      const period = (firstSeen !== '—' && lastSeen !== '—') ? `${firstSeen} – ${lastSeen}` : '—';
      card.innerHTML = `
        <div class="avatar"><img src="${info.img}" alt="${escapeHtml(champ)}" loading="lazy"></div>
        <div class="card-body">
          <div class="title">${escapeHtml(champ)}${badge}</div>
          <div class="meta-line">
            <span>Spiele: ${info.games}</span>
            <span>Top 4: ${info.top4} (${top4Rate})</span>
            <span>Top 1: ${info.top1} (${winRate})</span>
          </div>
          <div class="meta-line">
            <span>Ø Platzierung: ${avgPlacement}</span>
            <span>Beste Platzierung: ${info.bestPlacement ?? '—'}</span>
            <span>Schlechteste Platzierung: ${info.worstPlacement ?? '—'}</span>
          </div>
          <div class="meta-line">
            <span>Ø K/D/A: ${avgKills}/${avgDeaths}/${avgAssists}</span>
            <span>Ø KDA: ${nf2.format(kda)}</span>
            <span>Ø Schaden: ${avgDamage}</span>
          </div>
          <div class="meta-line">
            <span>Ø Gold: ${avgGold}</span>
            <span>Ø CS: ${avgCs}</span>
          </div>
          <div class="meta-line">
            <span>Zeitraum: ${escapeHtml(period)}</span>
            <span>Letztes Ergebnis: ${escapeHtml(lastResult)}</span>
            <span>Top-Mate: ${escapeHtml(favMate)}</span>
          </div>
        </div>`;
      els.grid.appendChild(card);
    }
  }

  function renderTeammates(map) {
    if (map) lastTeammateStats = map;
    const source = map || lastTeammateStats;
    if (!source || source.size === 0) {
      els.mateSection.hidden = true;
      els.mateContent.innerHTML = '';
      return;
    }
    const min = Math.max(1, parseInt(els.mateMin.value, 10) || 1);
    const rows = Array.from(source.values()).filter(entry => entry.games >= min)
      .sort((a, b) => {
        if (b.games !== a.games) return b.games - a.games;
        const wrA = a.games ? a.wins / a.games : 0;
        const wrB = b.games ? b.wins / b.games : 0;
        if (wrB !== wrA) return wrB - wrA;
        return (b.lastSeen || 0) - (a.lastSeen || 0);
      });
    if (rows.length === 0) {
      els.mateSection.hidden = false;
      els.mateContent.innerHTML = `<div class="hint">Keine Mitspieler mit mindestens ${min} gemeinsamen Spielen.</div>`;
      return;
    }
    const body = rows.map(entry => {
      const wr = percentText(entry.wins, entry.games);
      const top4 = percentText(entry.top4, entry.games);
      const champs = Array.from(entry.champions.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0,3)
        .map(([c,count]) => `${escapeHtml(c)} × ${count}`)
        .join(', ');
      return `<tr><td>${escapeHtml(entry.name)}</td><td>${entry.games}</td><td>${entry.wins}</td><td>${wr}</td><td>${top4}</td><td>${champs || '—'}</td></tr>`;
    }).join('');
    els.mateContent.innerHTML = `<table class="mate-table"><thead><tr><th>Name</th><th>Spiele</th><th>Siege</th><th>Win-Rate</th><th>Top 4-Rate</th><th>Champions</th></tr></thead><tbody>${body}</tbody></table>`;
    els.mateSection.hidden = false;
  }

  // --- Hauptlauf ---
  async function run(apiKey, gameName, tagLine, limit) {
    els.kvs.hidden = true;
    els.grid.innerHTML = '';
    els.advanced.hidden = true;
    els.mateSection.hidden = true;
    els.mateContent.innerHTML = '';
    lastTeammateStats = null;
    setStatus('', false);

    await ensureDataDragon();

    // Live: erst PUUID holen
    setStatus('Löse Riot ID…', true);
    const { puuid, display } = await resolvePlayer(gameName.trim(), (tagLine||'').trim(), apiKey);

    // Arena-IDs holen
    setStatus('Lade Arena-Match-IDs…', true);
    const ids = await fetchArenaMatchIds(puuid, limit, apiKey);
    if (ids.length === 0) {
      lastDataset = {
        version: 1, exportedAt: new Date().toISOString(), queues: ARENA_QUEUES,
        puuid, player: display, count: 0, matches: []
      };
      els.exportBtn.disabled = false;
      analyzeMatches([], puuid, display);
      setStatus('Keine Arena-Matches gefunden.');
      return;
    }

    // Matches laden und gleichzeitig für Export sammeln
    // Vorhandene Matches aus Import übernehmen
    const existing = new Map();
    if (importedDataset && importedDataset.puuid === puuid && Array.isArray(importedDataset.matches)) {
      for (const m of importedDataset.matches) {
        const id = m?.id || m?.metadata?.matchId;
        if (id) existing.set(id, m);
      }
    }

    const collected = Array.from(existing.values()); // bereits bekannte Matches
    const toFetch = ids.filter(id => !existing.has(id));

    setStatus('Lade & analysiere Arena-Matches…', true);
    let processed = 0;
    for (const id of toFetch) {
      const mUrl = `https://${REGION}.api.riotgames.com/lol/match/v5/matches/${id}`;
      try {
        const match = await fetchJson(mUrl, apiKey);
        const obj = { id: match?.metadata?.matchId || id, info: match.info, metadata: match.metadata };
        collected.push(obj);
        processed++;
        if (processed % 10 === 0) setStatus(`Geladen: ${processed}/${toFetch.length}…`, true);
        await sleep(100);
      } catch (e) {
        console.warn('Match fetch failed', id, e);
        await sleep(150);
      }
    }

    // Datensatz speichern & exportierbar machen
    lastDataset = {
      version: 1,
      exportedAt: new Date().toISOString(),
      queues: ARENA_QUEUES,
      puuid,
      player: display,
      count: collected.length,
      matches: collected
    };
    importedDataset = lastDataset;
    els.exportBtn.disabled = false;

    // Analyse durchführen
    analyzeMatches(collected, puuid, display);
  }

  // --- Events ---
  els.form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const apiKey = getStoredApiKey();
    const gameName = els.gameName.value.trim();
    const tagLine = els.tagLine.value.trim();
    const limit = parseInt(els.limit.value, 10);

    if (!apiKey) {
      setStatus('Fehlender Riot API-Key. Bitte in der Konfiguration hinterlegen.', false, true);
      alert('Kein Riot API-Key hinterlegt. Öffne die Konfiguration und trage den Key ein.');
      updateKeyStatus();
      return;
    }

    if (!gameName) {
      setStatus('Bitte Riot-ID-Name angeben.', false, true);
      return;
    }

    els.go.disabled = true;
    try {
      await run(apiKey, gameName, tagLine, limit);
    } catch (e) {
      setStatus('Fehler: ' + e.message, false, true);
    } finally {
      els.go.disabled = false;
    }
  });

  // Import
  els.importBtn.addEventListener('click', () => els.importFile.click());
  els.importFile.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      if (!obj || !Array.isArray(obj.matches)) throw new Error('Ungültiges Format: "matches" fehlt');
      importedDataset = obj;
      lastDataset = obj;
      els.importInfo.textContent = `Importiert: ${obj.player || 'Unbekannt'} • Matches: ${obj.count ?? obj.matches.length} • Exportiert am: ${obj.exportedAt || '—'}`;
      els.exportBtn.disabled = false; // Re-Export erlauben
      setStatus('Datensatz importiert. Fehlende Spiele werden beim Analysieren ergänzt.');
    } catch (err) {
      setStatus('Import fehlgeschlagen: ' + err.message, false, true);
      importedDataset = null;
      lastDataset = null;
      els.importInfo.textContent = 'Import fehlgeschlagen.';
    } finally {
      // Reset, damit gleiche Datei erneut wählbar ist
      e.target.value = '';
    }
  });

  // Export
  els.exportBtn.addEventListener('click', () => {
    if (!lastDataset) {
      setStatus('Nichts zu exportieren – bitte zuerst Matches laden oder einen Datensatz importieren.', false, true);
      return;
    }
    const nameSafe = (lastDataset.player || 'dataset').replace(/[^A-Za-z0-9_\-#]+/g,'_');
    downloadJSON(`arena_dataset_${nameSafe}.json`, lastDataset);
    setStatus('Datensatz exportiert.');
  });

  els.mateMin.addEventListener('input', () => {
    if (lastTeammateStats) renderTeammates();
  });

  // Demo
  els.demo.addEventListener('click', async () => {
    await ensureDataDragon();
    const base = Date.now();
    const demoPuuid = 'demo-puuid';
    const demoMatches = [
      {
        id: 'DEMO_1',
        info: {
          queueId: 1700,
          gameCreation: base - 86400000,
          gameDuration: 1150,
          participants: [
            { puuid: demoPuuid, riotIdGameName: 'Demo', riotIdTagline: 'EUW', championId: 103, championName: 'Ahri', kills: 12, deaths: 3, assists: 9, goldEarned: 15234, totalDamageDealtToChampions: 28045, totalMinionsKilled: 98, neutralMinionsKilled: 24, playerSubteamId: 1, subteamPlacement: 1 },
            { puuid: 'mate-1', riotIdGameName: 'LuxMain', riotIdTagline: 'EUW', championId: 99, championName: 'Lux', kills: 5, deaths: 4, assists: 15, goldEarned: 14021, totalDamageDealtToChampions: 23500, totalMinionsKilled: 24, neutralMinionsKilled: 6, playerSubteamId: 1, subteamPlacement: 1 },
            { puuid: 'opp-1a', riotIdGameName: 'BruiserOne', riotIdTagline: 'EUW', championId: 122, championName: 'Darius', kills: 10, deaths: 6, assists: 4, goldEarned: 13500, totalDamageDealtToChampions: 26000, totalMinionsKilled: 85, neutralMinionsKilled: 20, playerSubteamId: 2, subteamPlacement: 2 },
            { puuid: 'opp-1b', riotIdGameName: 'BruiserTwo', riotIdTagline: 'EUW', championId: 420, championName: 'Illaoi', kills: 6, deaths: 7, assists: 5, goldEarned: 12800, totalDamageDealtToChampions: 21000, totalMinionsKilled: 70, neutralMinionsKilled: 15, playerSubteamId: 2, subteamPlacement: 2 },
            { puuid: 'opp-2a', riotIdGameName: 'MageOne', riotIdTagline: 'EUW', championId: 61, championName: 'Orianna', kills: 4, deaths: 5, assists: 10, goldEarned: 12000, totalDamageDealtToChampions: 19000, totalMinionsKilled: 65, neutralMinionsKilled: 10, playerSubteamId: 3, subteamPlacement: 3 },
            { puuid: 'opp-2b', riotIdGameName: 'MageTwo', riotIdTagline: 'EUW', championId: 134, championName: 'Syndra', kills: 7, deaths: 8, assists: 6, goldEarned: 11800, totalDamageDealtToChampions: 20500, totalMinionsKilled: 60, neutralMinionsKilled: 8, playerSubteamId: 3, subteamPlacement: 3 },
            { puuid: 'opp-3a', riotIdGameName: 'AssassinOne', riotIdTagline: 'EUW', championId: 238, championName: 'Zed', kills: 8, deaths: 7, assists: 3, goldEarned: 12500, totalDamageDealtToChampions: 24000, totalMinionsKilled: 75, neutralMinionsKilled: 18, playerSubteamId: 4, subteamPlacement: 4 },
            { puuid: 'opp-3b', riotIdGameName: 'AssassinTwo', riotIdTagline: 'EUW', championId: 55, championName: 'Katarina', kills: 11, deaths: 9, assists: 2, goldEarned: 13200, totalDamageDealtToChampions: 25000, totalMinionsKilled: 80, neutralMinionsKilled: 12, playerSubteamId: 4, subteamPlacement: 4 },
          ],
        },
      },
      {
        id: 'DEMO_2',
        info: {
          queueId: 1700,
          gameCreation: base - 2 * 86400000,
          gameDuration: 980,
          participants: [
            { puuid: demoPuuid, riotIdGameName: 'Demo', riotIdTagline: 'EUW', championId: 122, championName: 'Darius', kills: 9, deaths: 5, assists: 6, goldEarned: 14200, totalDamageDealtToChampions: 25500, totalMinionsKilled: 90, neutralMinionsKilled: 18, playerSubteamId: 1, subteamPlacement: 3 },
            { puuid: 'mate-1', riotIdGameName: 'LuxMain', riotIdTagline: 'EUW', championId: 16, championName: 'Soraka', kills: 2, deaths: 3, assists: 14, goldEarned: 12050, totalDamageDealtToChampions: 14500, totalMinionsKilled: 18, neutralMinionsKilled: 4, playerSubteamId: 1, subteamPlacement: 3 },
            { puuid: 'opp-4a', riotIdGameName: 'TankLord', riotIdTagline: 'EUW', championId: 32, championName: 'Amumu', kills: 3, deaths: 4, assists: 11, goldEarned: 11800, totalDamageDealtToChampions: 16000, totalMinionsKilled: 60, neutralMinionsKilled: 12, playerSubteamId: 2, subteamPlacement: 1 },
            { puuid: 'opp-4b', riotIdGameName: 'BladeQueen', riotIdTagline: 'EUW', championId: 498, championName: 'Xayah', kills: 8, deaths: 2, assists: 7, goldEarned: 14600, totalDamageDealtToChampions: 27000, totalMinionsKilled: 92, neutralMinionsKilled: 16, playerSubteamId: 2, subteamPlacement: 1 },
            { puuid: 'opp-5a', riotIdGameName: 'SupportGuru', riotIdTagline: 'EUW', championId: 412, championName: 'Thresh', kills: 1, deaths: 5, assists: 12, goldEarned: 10900, totalDamageDealtToChampions: 9000, totalMinionsKilled: 25, neutralMinionsKilled: 5, playerSubteamId: 3, subteamPlacement: 2 },
            { puuid: 'opp-5b', riotIdGameName: 'MarksmanMain', riotIdTagline: 'EUW', championId: 236, championName: 'Lucian', kills: 11, deaths: 4, assists: 5, goldEarned: 15050, totalDamageDealtToChampions: 28000, totalMinionsKilled: 95, neutralMinionsKilled: 20, playerSubteamId: 3, subteamPlacement: 2 },
            { puuid: 'opp-6a', riotIdGameName: 'BruiserKing', riotIdTagline: 'EUW', championId: 86, championName: 'Garen', kills: 5, deaths: 7, assists: 4, goldEarned: 11000, totalDamageDealtToChampions: 18000, totalMinionsKilled: 70, neutralMinionsKilled: 12, playerSubteamId: 4, subteamPlacement: 4 },
            { puuid: 'opp-6b', riotIdGameName: 'AssassinEdge', riotIdTagline: 'EUW', championId: 91, championName: 'Talon', kills: 7, deaths: 8, assists: 3, goldEarned: 11900, totalDamageDealtToChampions: 19500, totalMinionsKilled: 68, neutralMinionsKilled: 10, playerSubteamId: 4, subteamPlacement: 4 },
          ],
        },
      },
      {
        id: 'DEMO_3',
        info: {
          queueId: 1700,
          gameCreation: base - 3 * 86400000,
          gameDuration: 1025,
          participants: [
            { puuid: demoPuuid, riotIdGameName: 'Demo', riotIdTagline: 'EUW', championId: 145, championName: 'KaiSa', kills: 6, deaths: 7, assists: 5, goldEarned: 13000, totalDamageDealtToChampions: 21000, totalMinionsKilled: 88, neutralMinionsKilled: 14, playerSubteamId: 1, subteamPlacement: 4 },
            { puuid: 'mate-2', riotIdGameName: 'BruiserBuddy', riotIdTagline: 'EUW', championId: 59, championName: 'JarvanIV', kills: 3, deaths: 8, assists: 9, goldEarned: 11500, totalDamageDealtToChampions: 15000, totalMinionsKilled: 55, neutralMinionsKilled: 12, playerSubteamId: 1, subteamPlacement: 4 },
            { puuid: 'opp-7a', riotIdGameName: 'MagePro', riotIdTagline: 'EUW', championId: 101, championName: 'Xerath', kills: 9, deaths: 4, assists: 11, goldEarned: 14400, totalDamageDealtToChampions: 30000, totalMinionsKilled: 100, neutralMinionsKilled: 18, playerSubteamId: 2, subteamPlacement: 1 },
            { puuid: 'opp-7b', riotIdGameName: 'ShieldHero', riotIdTagline: 'EUW', championId: 201, championName: 'Braum', kills: 2, deaths: 5, assists: 18, goldEarned: 11200, totalDamageDealtToChampions: 11000, totalMinionsKilled: 35, neutralMinionsKilled: 6, playerSubteamId: 2, subteamPlacement: 1 },
            { puuid: 'opp-8a', riotIdGameName: 'BladeDance', riotIdTagline: 'EUW', championId: 39, championName: 'Irelia', kills: 8, deaths: 5, assists: 6, goldEarned: 13800, totalDamageDealtToChampions: 24000, totalMinionsKilled: 97, neutralMinionsKilled: 20, playerSubteamId: 3, subteamPlacement: 2 },
            { puuid: 'opp-8b', riotIdGameName: 'StormEdge', riotIdTagline: 'EUW', championId: 10, championName: 'Kayle', kills: 9, deaths: 6, assists: 7, goldEarned: 14050, totalDamageDealtToChampions: 26000, totalMinionsKilled: 110, neutralMinionsKilled: 15, playerSubteamId: 3, subteamPlacement: 2 },
            { puuid: 'opp-9a', riotIdGameName: 'ShadowBlade', riotIdTagline: 'EUW', championId: 141, championName: 'Kayn', kills: 10, deaths: 6, assists: 4, goldEarned: 13600, totalDamageDealtToChampions: 25500, totalMinionsKilled: 90, neutralMinionsKilled: 16, playerSubteamId: 4, subteamPlacement: 3 },
            { puuid: 'opp-9b', riotIdGameName: 'FrostQueen', riotIdTagline: 'EUW', championId: 117, championName: 'Lulu', kills: 1, deaths: 5, assists: 17, goldEarned: 11800, totalDamageDealtToChampions: 9500, totalMinionsKilled: 28, neutralMinionsKilled: 5, playerSubteamId: 4, subteamPlacement: 3 },
          ],
        },
      },
    ];

    const datasetMatches = demoMatches.map(m => ({ id: m.id, info: m.info }));
    analyzeMatches(datasetMatches, demoPuuid, 'Demo#EUW');
    lastDataset = {
      version: 1,
      exportedAt: new Date().toISOString(),
      queues: ARENA_QUEUES,
      puuid: demoPuuid,
      player: 'Demo#EUW',
      count: datasetMatches.length,
      matches: datasetMatches,
    };
    importedDataset = lastDataset;
    els.exportBtn.disabled = false;
    setStatus('Demo-Modus (keine Riot-Calls).');
  });
})();
</script>
</body>
</html>
