<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arena-Siege pro Champion (EUW, Riot API)</title>
  <style>
    :root { --bg:#0b1020; --card:#131a2a; --muted:#8fa1c7; --text:#e9f0ff; --accent:#6aa9ff; --bad:#ff6a6a; --good:#56d364; }
    *{box-sizing:border-box} body{margin:0;background:radial-gradient(1000px 600px at 10% -10%,#14203e 0,#0b1020 50%,#090e1a 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:28px 20px 10px; text-align:center}
    h1{margin:0 0 6px; font-size:clamp(20px,3.5vw,28px); letter-spacing:.2px}
    p.sub{margin:.25rem 0 1rem; color:var(--muted)}
    .wrap{max-width:1100px;margin:0 auto; padding:0 16px 40px}
    form.tools{display:grid;gap:12px;grid-template-columns:1fr 1fr;align-items:end;margin:18px auto 14px; max-width:920px}
    .field{display:flex;flex-direction:column; gap:6px}
    label{font-size:13px;color:var(--muted)}
    input, select{background:var(--card);border:1px solid #1e2a44;color:var(--text);padding:10px 12px;border-radius:10px;outline:none}
    input::placeholder{color:#6f7ea5}
    .row{display:flex; gap:10px; align-items:center}
    button{background:linear-gradient(180deg,#3b6dd8,#2c5ac0); border:0; color:#fff; padding:12px 16px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(59,109,216,.25)}
    button:disabled{opacity:.6; cursor:not-allowed; box-shadow:none}
    .hint{font-size:13px;color:var(--muted)}
    .status{margin:10px 0 18px; font-size:14px; color:var(--muted)}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); gap:14px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.0)); border:1px solid #1f2942; border-radius:16px; padding:14px; display:flex; gap:12px; align-items:center}
    .avatar{width:56px;height:56px;border-radius:12px; overflow:hidden; flex:0 0 auto; border:1px solid #2a395f}
    .avatar img{width:100%;height:100%;object-fit:cover; display:block}
    .title{font-weight:700; font-size:16px}
    .meta{font-size:12px; color:var(--muted)}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #28406f; margin-top:6px}
    .success{color:var(--good); border-color:#2f6b50}
    details.tips{margin:14px 0; color:var(--muted)}
    details.tips summary{cursor:pointer}
    .footer{margin-top:26px; font-size:12px; color:#6f7ea5}
    .sep{opacity:.25}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid #4d5f8f;border-top-color:#9fb7ff;border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px;margin-right:8px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .error{color:#ff9c9c}
    .muted{color:var(--muted)}
    .kvs{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:10px; margin:10px 0 18px}
    .kv{background:var(--card); border:1px dashed #28406f; border-radius:12px; padding:10px 12px; font-size:13px}
    code.small{background:#0e1427; padding:2px 6px; border-radius:6px; border:1px solid #223058}
  </style>
</head>
<body>
<header>
  <h1>Arena-Siege pro Champion</h1>
  <p class="sub">EUW fest eingestellt • Liest Matches & filtert auf <strong>Arena</strong> (queue 1700 / gameMode CHERRY)</p>
</header>

<div class="wrap">
  <form class="tools" id="form">
    <div class="field">
      <label for="apiKey">Riot API-Key</label>
      <input id="apiKey" type="password" placeholder="RGAPI-xxxx..." required />
      <div class="hint">Dein Key wird nur im Browser benutzt.</div>
    </div>

    <div class="field">
      <label for="name">Beschwörername (EUW)</label>
      <input id="name" type="text" placeholder="z. B. Faker EUW" required />
    </div>

    <div class="field">
      <label for="limit">Max. Matches durchsuchen</label>
      <select id="limit">
        <option value="100">100 (schnell)</option>
        <option value="200" selected>200</option>
        <option value="300">300</option>
        <option value="500">500</option>
        <option value="800">800</option>
        <option value="1000">1000 (langsam, Rate-Limit beachten)</option>
      </select>
    </div>

    <div class="field">
      <label for="proxy">Optional: Proxy-Basis-URL <span class="muted">(gegen CORS)</span></label>
      <input id="proxy" type="url" placeholder="https://dein-proxy.example.com" />
      <div class="hint">Leer lassen für Direktaufrufe. Bei CORS-Fehlern ein Proxy verwenden (siehe Tipps unten).</div>
    </div>

    <div class="row">
      <button id="go" type="submit">Analysieren</button>
      <button id="demo" type="button" title="Kein echter Call – zeigt nur Oberfläche">Demo-Modus</button>
    </div>
  </form>

  <div class="status" id="status"></div>

  <div class="kvs" id="kvs" hidden>
    <div class="kv"><strong>Beschwörer:</strong> <span id="kv-sum"></span></div>
    <div class="kv"><strong>Durchsuchte Matches:</strong> <span id="kv-scanned"></span></div>
    <div class="kv"><strong>Arena-Matches gefunden:</strong> <span id="kv-arena"></span></div>
    <div class="kv"><strong>Champions mit ≥1 Sieg:</strong> <span id="kv-unique"></span></div>
  </div>

  <div class="grid" id="grid"></div>

  <details class="tips">
    <summary>Tipps zu CORS / Proxy</summary>
    <div style="margin-top:8px">
      Browser blockieren häufig direkte Aufrufe zu <code class="small">*.api.riotgames.com</code>. Nutze dann einen dünnen Proxy. Beispiel „Cloudflare Worker“ (vereinfacht):
      <pre style="white-space:pre-wrap;background:#0e1427;border:1px solid #223058;border-radius:10px;padding:10px;overflow:auto"><code>// Wrangler/Worker (TypeScript/JS)
export default {
  async fetch(req) {
    const url = new URL(req.url)
    const upstream = url.searchParams.get("up") // komplette Riot-URL per ?up=
    if (!upstream) return new Response("Missing up", { status: 400 })
    return fetch(upstream, {
      headers: { "X-Riot-Token": req.headers.get("X-Riot-Token") ?? "" }
    })
  }
}
// Aufruf im Tool: https://dein-worker.workers.dev/?up=https://europe.api.riotgames.com/lol/match/v5/matches/...</code></pre>
      Trage die Proxy-Basis oben ein (ohne Pfad). Der Code hier ist nur ein Beispiel – sichere ihn in der Praxis ab.
    </div>
  </details>

  <div class="footer">
    <span class="sep">•</span> Daten: Riot Match-v5, Summoner-v4, Data-Dragon <span class="sep">•</span>
    <span class="muted">Dieses Tool respektiert Rate-Limits (kleine Pausen zwischen Requests).</span>
  </div>
</div>

<script>
(() => {
  const els = {
    form: document.getElementById('form'),
    apiKey: document.getElementById('apiKey'),
    name: document.getElementById('name'),
    limit: document.getElementById('limit'),
    proxy: document.getElementById('proxy'),
    status: document.getElementById('status'),
    grid: document.getElementById('grid'),
    kvs: document.getElementById('kvs'),
    kvSum: document.getElementById('kv-sum'),
    kvScanned: document.getElementById('kv-scanned'),
    kvArena: document.getElementById('kv-arena'),
    kvUnique: document.getElementById('kv-unique'),
    go: document.getElementById('go'),
    demo: document.getElementById('demo')
  };

  const PLATFORM = 'euw1';    // Summoner-v4
  const REGION   = 'europe';  // Match-v5
  const ARENA_QUEUE_ID = 1700;
  const ARENA_MODE = 'CHERRY';

  let ddVer = null;           // Data Dragon version (e.g. "14.17.1")
  let champByKey = null;      // Map<string championKey -> { id, name }>

  function setStatus(msg, spinning = false, isError = false) {
    els.status.innerHTML = (spinning ? '<span class="spinner"></span>' : '') + (isError ? '<span class="error">' + msg + '</span>' : msg);
  }

  function sleep(ms){return new Promise(res=>setTimeout(res,ms))}

  // NEU: robustes Auflösen von Summoner/PUUID (unterstützt "name#tag" und reinen Summonernamen)
async function resolvePlayer(nameInput, apiKey, proxyBase) {
  // Wenn eine Tagline dabei ist (Riot ID): Account-v1 -> puuid -> SummonerByPUUID
  if (nameInput.includes('#')) {
    const [gameName, tagLine] = nameInput.split('#');
    const accUrl = withProxy(
      proxyBase,
      `https://${REGION}.api.riotgames.com/riot/account/v1/accounts/by-riot-id/${encodeURIComponent(gameName)}/${encodeURIComponent(tagLine)}`
    );
    const account = await fetchJson(accUrl, apiKey); // { puuid, gameName, tagLine }
    const sumByPuuidUrl = withProxy(
      proxyBase,
      `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-puuid/${encodeURIComponent(account.puuid)}`
    );
    const summoner = await fetchJson(sumByPuuidUrl, apiKey); // { id, accountId, puuid, name, ... }
    return { puuid: account.puuid, summonerName: summoner.name };
  }

  // Sonst: klassisch Summoner-v4 by-name
  const sumUrl = withProxy(
    proxyBase,
    `https://${PLATFORM}.api.riotgames.com/lol/summoner/v4/summoners/by-name/${encodeURIComponent(nameInput)}`
  );
  const summoner = await fetchJson(sumUrl, apiKey);
  return { puuid: summoner.puuid, summonerName: summoner.name };
}



  function withProxy(base, url) {
    if (!base) return url;
    // Encode the target URL as query param ?up=
    const u = new URL(base);
    u.searchParams.set('up', url);
    return u.toString();
  }

  async function fetchJson(url, apiKey) {
    const res = await fetch(url, { headers: { 'X-Riot-Token': apiKey }});
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error('HTTP ' + res.status + ' – ' + text.slice(0,200));
    }
    return res.json();
  }

  async function ensureDataDragon() {
    if (ddVer && champByKey) return;
    // Get latest DDragon version
    const vers = await fetch('https://ddragon.leagueoflegends.com/api/versions.json').then(r=>r.json());
    ddVer = vers[0];
    const ddUrl = `https://ddragon.leagueoflegends.com/cdn/${ddVer}/data/en_US/champion.json`;
    const data = await fetch(ddUrl).then(r=>r.json());
    champByKey = {};
    for (const id in data.data) {
      const c = data.data[id]; // { id: "Ahri", key: "103", name: "Ahri", ...}
      champByKey[c.key] = { id: c.id, name: c.name };
    }
  }

  function champAssetByParticipant(part) {
    // Prefer championId -> DDragon id for robust image filename
    const key = String(part.championId);
    if (champByKey && champByKey[key]) {
      const ddId = champByKey[key].id;
      return {
        img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${ddId}.png`,
        label: champByKey[key].name
      };
    }
    // Fallback to championName
    const safe = (part.championName || 'Unknown').replace(/[^A-Za-z]/g,'');
    return {
      img: `https://ddragon.leagueoflegends.com/cdn/${ddVer}/img/champion/${safe}.png`,
      label: part.championName || 'Unknown'
    };
  }

  function renderResults(summonerName, scanned, arenaCount, winners) {
    els.kvSum.textContent = summonerName + ' (EUW)';
    els.kvScanned.textContent = scanned;
    els.kvArena.textContent = arenaCount;
    els.kvUnique.textContent = winners.size;
    els.kvs.hidden = false;

    els.grid.innerHTML = '';
    // Sort: most wins first, then name
    const rows = Array.from(winners.entries()).sort((a,b)=>{
      const aw=a[1].wins, bw=b[1].wins;
      if (bw!==aw) return bw-aw;
      return a[0].localeCompare(b[0]);
    });

    for (const [champ, info] of rows) {
      const card = document.createElement('div');
      card.className = 'card';
      const imgWrap = document.createElement('div');
      imgWrap.className = 'avatar';
      const img = document.createElement('img');
      img.src = info.img;
      img.alt = champ;
      img.loading = 'lazy';
      imgWrap.appendChild(img);
      const body = document.createElement('div');
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = champ;
      const meta = document.createElement('div');
      meta.className = 'meta';
      const last = info.lastWin ? new Date(info.lastWin).toLocaleString() : '—';
      meta.textContent = `Siege: ${info.wins} • Letzter Sieg: ${last}`;
      const pill = document.createElement('span');
      pill.className = 'pill success';
      pill.textContent = 'Arena ✓';
      body.appendChild(title);
      body.appendChild(meta);
      body.appendChild(pill);
      card.appendChild(imgWrap);
      card.appendChild(body);
      els.grid.appendChild(card);
    }

    if (rows.length === 0) {
      els.grid.innerHTML = '<div class="kv">Keine Champions mit Arena-Sieg gefunden (in den betrachteten Matches).</div>';
    }
  }

  async function run(apiKey, summonerName, limit, proxyBase) {
    els.grid.innerHTML = '';
    els.kvs.hidden = true;
    setStatus('Lade Data-Dragon-Katalog…', true);
    await ensureDataDragon();

    setStatus('Suche Beschwörer…', true);
    const { puuid, summonerName: resolvedName } = await resolvePlayer(summonerName, apiKey, proxyBase);

    // Pull match IDs in pages of 100 (max). We’ll post-filter on Arena.
    setStatus('Lade Match-IDs…', true);
    const ids = [];
    let start = 0;
    const step = 100;
    while (ids.length < limit) {
      const count = Math.min(step, limit - ids.length);
      const idsUrl = withProxy(proxyBase, `https://${REGION}.api.riotgames.com/lol/match/v5/matches/by-puuid/${encodeURIComponent(puuid)}/ids?start=${start}&count=${count}`);
      const page = await fetchJson(idsUrl, apiKey);
      ids.push(...page);
      if (page.length < count) break; // no more
      start += count;
      await sleep(120); // be nice to rate limits
      setStatus(`Match-IDs geladen: ${ids.length}/${limit}…`, true);
    }

    // For each id, get match and filter Arena + wins
    const winners = new Map(); // champName -> { wins, lastWin, img }
    let arenaCount = 0;
    let scanned = 0;

    setStatus('Analysiere Matches…', true);
    for (const id of ids) {
      const mUrl = withProxy(proxyBase, `https://${REGION}.api.riotgames.com/lol/match/v5/matches/${id}`);
      try {
        const match = await fetchJson(mUrl, apiKey);
        scanned++;
        const info = match.info || {};
        const isArena = (info.queueId === ARENA_QUEUE_ID) || (info.gameMode === ARENA_MODE);
        if (!isArena) {
          if (scanned % 15 === 0) setStatus(`Analysiere Matches… (${scanned}/${ids.length})`, true);
          await sleep(60);
          continue;
        }
        arenaCount++;
        const me = (info.participants || []).find(p => p.puuid === puuid);
        if (me && me.win) {
          const asset = champAssetByParticipant(me);
          const key = asset.label;
          if (!winners.has(key)) winners.set(key, { wins: 0, lastWin: 0, img: asset.img });
          const slot = winners.get(key);
          slot.wins += 1;
          slot.lastWin = Math.max(slot.lastWin || 0, (info.gameEndTimestamp || info.gameStartTimestamp || 0));
        }
        if (scanned % 10 === 0) setStatus(`Arena-Matches: ${arenaCount} • Fortschritt ${scanned}/${ids.length}`, true);
        await sleep(120); // pace requests
      } catch (e) {
        // If a single match fails, continue
        console.warn('Match fetch failed', id, e);
        await sleep(150);
      }
    }

    renderResults(resolvedName, scanned, arenaCount, winners);
    setStatus(`Fertig. Gefundene Champions mit ≥1 Arena-Sieg: ${winners.size}.`);
  }

  els.form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const apiKey = els.apiKey.value.trim();
    const name = els.name.value.trim();
    const limit = parseInt(els.limit.value, 10);
    const proxy = els.proxy.value.trim();
    if (!apiKey || !name) {
      setStatus('Bitte API-Key und Beschwörernamen angeben.', false, true);
      return;
    }
    els.go.disabled = true;
    try {
      await run(apiKey, name, limit, proxy || '');
    } catch (e) {
      setStatus('Fehler: ' + e.message, false, true);
    } finally {
      els.go.disabled = false;
    }
  });

  els.demo.addEventListener('click', () => {
    // Demo: baut Beispielkarten ohne echte API-Calls (UI-Vorschau).
    const winners = new Map();
    winners.set('Ahri', { wins: 3, lastWin: Date.now() - 86400000*2, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Ahri.png` });
    winners.set('Darius', { wins: 1, lastWin: Date.now() - 86400000*5, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Darius.png` });
    winners.set('Kai\'Sa', { wins: 2, lastWin: Date.now() - 3600*1000*6, img: `https://ddragon.leagueoflegends.com/cdn/14.17.1/img/champion/Kaisa.png` });
    els.kvs.hidden = false;
    els.kvSum.textContent = 'Demo (EUW)';
    els.kvScanned.textContent = 120;
    els.kvArena.textContent = 34;
    els.kvUnique.textContent = winners.size;
    els.grid.innerHTML = '';
    for (const [name, info] of winners.entries()) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="avatar"><img src="${info.img}" alt="${name}" loading="lazy"></div>
        <div>
          <div class="title">${name}</div>
          <div class="meta">Siege: ${info.wins} • Letzter Sieg: ${new Date(info.lastWin).toLocaleString()}</div>
          <span class="pill success">Arena ✓</span>
        </div>`;
      els.grid.appendChild(card);
    }
    setStatus('Demo-Modus aktiv (keine Riot-Calls).');
  });
})();
</script>
</body>
</html>
